getpearson<-function(z){
temp_df <- subset(trialdata_passes,participant==z)
pearson <- cor(x=temp_df$firstpass_similarity, y=temp_df$secondpass_similarity, method="pearson")
return(pearson)
}
getspearman<-function(z){
temp_df <- subset(trialdata_passes,participant==z)
spearman <- cor(x=temp_df$firstpass_similarity, y=temp_df$secondpass_similarity, method="spearman")
return(spearman)
}
pass_correlation$pearson<-lapply(participants_complete$participant, getpearson) #apply fn
pass_correlation$spearman<-lapply(participants_complete$participant, getspearman)
#make correlation numeric for graphing
pass_correlation$pearson<-as.numeric(pass_correlation$pearson)
pass_correlation$spearman<-as.numeric(pass_correlation$spearman)
#if error: check trialdata_passes that resulted in NA correlation
unique(unlist (lapply (pass_correlation, function (x) which (is.na (x)))))
#trialdata_passes[trialdata_passes$participant == '61652222bfd9351c91a6585a',]
#drop rows with NA correlation #
pass_correlation<- na.omit(pass_correlation)
#covert rho to fisher's z
#x=rho value
get_fisherz <-function(x){
variable<-(0.5*(log(1+x) - log(1-x)) )
return(variable)
}
pass_correlation$fisherz <- lapply(pass_correlation[,"pearson"], get_fisherz) #apply function
pass_correlation$fisherz<-as.numeric(pass_correlation$fisherz)
}
#REASONABLE THRESHOLD OF EXCLUSION (Doublepass cor below 2SD)
{
#save mean fisherz
mean_z<- round(mean(pass_correlation$fisherz), 2)
sd_z<- round(sd(pass_correlation$fisherz), 2)
#Participants below 2 standard deviation of mean correlation
outsiders <- pass_correlation[pass_correlation$fisherz<(mean_z-2*sd_z),]
pass_correlation <- subset(pass_correlation, !participant %in% outsiders$participant)
trialdata <- subset(trialdata, !participant %in% participants_incomplete$participant_id)
trialdata <- subset(trialdata, !participant %in% outsiders$participant)
}
{
#MAKE DATAFRAME WITH ONE ROW PER ANSWER
{
IH_vars<- c("participant", "Ishi_textbox.text", "imageaddress")
#"Ishi_trial_keyresp.rt",
#make catch data frame
IHdata<-data[IH_vars]
#remove empty cells
IHdata <- IHdata %>% drop_na()
}
#Scoring reference
scoringtable<- read_excel("PictureConditions.xlsx")
#inserting correct answers to participants dataframe
IHdata <- merge(IHdata, scoringtable, by= "imageaddress")
#coercing answers into numeric for efficient matching
IHdata$answer.numeric <- as.numeric(IHdata$Ishi_textbox.text)
IHdata$match <- IHdata$answer.numeric==IHdata$correctanswer
#MAKE IH_PERPERSON DATAFRAME WITH ONE ROW PER PARTICIPANT
{
#make dataframe with IH scores
IH_perperson<- data.frame(unique(IHdata$participant))
IH_perperson<-rename(IH_perperson, participant = unique.IHdata.participant.)
}
#get IH correctly answered
{get_IHcorrectQs<- function(z){
temp_df <- subset(IHdata,participant==z)
correct_IH<- nrow(subset(temp_df,match==TRUE))
return(correct_IH)
}
IH_perperson$correctA<-lapply(IH_perperson$participant, get_IHcorrectQs)
IH_perperson$correctA <- as.numeric(IH_perperson$correctA)
}
#get IH questions answered
{get_IHtotal_answered<- function(z){
temp_df <- subset(IHdata,participant==z)
total_IH <- nrow(temp_df)
return(total_IH)
}
IH_perperson$total_answered<-lapply(IH_perperson$participant, get_IHtotal_answered)
IH_perperson$total_answered <- as.numeric(IH_perperson$total_answered)
}
#subsetting a single participant if required
#singleIHdata<-IHdata[IHdata$participant == "61716a16c157db249e36fc46", ]
#head(singleIHdata)
#these participant submitted two files
IH_perperson <- subset(IH_perperson,!participant == "61716a16c157db249e36fc46")
IH_perperson <- subset(IH_perperson,!participant == "614deecf67f2c8ccfe3df23b")
#Distribution of IH scores
ggplot(IH_perperson, aes(correctA)) +
geom_histogram() +
scale_x_continuous(breaks = as.numeric(round(quantile(IH_perperson$correctA),digits = 2))) +
theme_pubr() +
theme(axis.line = element_blank())+
geom_rangeframe()+
labs(x="Ishihara score",
title= "Histogram of Ishihara score")
#below threshold of normal colour vision
IH_perperson.low <- subset(IH_perperson, correctA <14)
#Removing participants with low Ishihara scores
trialdata_passes <- subset(trialdata_passes, !participant %in% IH_perperson.low$participant)
}
#MAKE DATAFRAME OF COLOURPAIRS
{
#get unique hex arrangements
colourpairs <- unique(trialdata_passes[ , c("hex1", "hex2")])
#Create unique pair name by concatening first colour with second colour
colourpairs$pair <- str_c(colourpairs$hex1, '',colourpairs$hex2)
#do the same for trialdata_passes
trialdata_passes$pairofcolour <- str_c(trialdata_passes$hex1, '',trialdata_passes$hex2)
}
#Counting times a colour pair was tested
get_pair_hitcount<-function(x){ #get number of hits on pair of colour (x = colourpair)
pair_hitcount<-sum(trialdata_passes$pairofcolour == x)
return(pair_hitcount)
}
colourpairs$pair_hitcount <-lapply(colourpairs$pair, get_pair_hitcount)
colourpairs$pair_hitcount <- as.integer(colourpairs$pair_hitcount)
#MAKE DATAFRAME WITH MEAN SIMILARITY PER COLOUR PAIR MAINTAINING DIRECTIONNALITY (AB=/=BA)
{
#mean_similarity<-colourpairs
#mean_similarity$mean<-NA
#for (x in 1:nrow(mean_similarity)) {#  #makes a temporary dataframe with all the similarity ratings for one colourpair (x = row in mean_similarity ie. one per colourpair)
#  a<-subset(trialdata_passes,trialdata_passes$hex1==mean_similarity$hex1[x] & trialdata_passes$hex2==mean_similarity$hex2[x], c(firstpass_similarity, secondpass_similarity)) #similarity with exact hex match
#  b<-subset(trialdata_passes,trialdata_passes$hex1==mean_similarity$hex2[x] & trialdata_passes$hex2==mean_similarity$hex1[x], c(firstpass_similarity, secondpass_similarity)) #similarity with flipped hex order
#  c<-rbind(a, b) #all similarty ratings for colour pair x
#  mean_similarity$mean[x]<-mean(as.matrix(c))
#}
get_mean_similarity <- function(z){
a<-subset(trialdata_passes, pairofcolour==z) #similarity with exact hex match
mean<-mean(a$similarity)
return(mean)
}
colourpairs$mean.similarity<-lapply(colourpairs$pair, get_mean_similarity)
colourpairs$mean.similarity<- as.numeric(colourpairs$mean.similarity)
}
#MAKE DATAFRAME WITH ASYMMETRY INDEX (AsIn) for each participant SIMPLIFIED FORMULA
{
#Calculating absolute difference between first and second pass similatirity ratings
trialdata_passes$abs <- abs(trialdata_passes$firstpass_similarity-trialdata_passes$secondpass_similarity)
#Creating unique ID for each pair by combining participant ID and Colourpair
trialdata_passes$Colourpairperparticipant <- str_c(trialdata_passes$participant, '',trialdata_passes$Colourpair)
#selecting variables for asymmetry analysis
AsIndata_vars <- c("participant", "Colourpair", "Temporder", "hex1", "hex2", "similarity", "abs", "Colourpairperparticipant")
#making dataframe
AsIndata <- trialdata_passes[AsIndata_vars]
#changing to wide so that One row per colour pair per participant (4 ratings per row, first and second pass and reverse order)
AsIndata_wide <- reshape(AsIndata, idvar = "Colourpairperparticipant", timevar = "Temporder", direction = "wide")
#renaming because temporder first second makes it confusing with first/second pass
names(AsIndata_wide)[names(AsIndata_wide) == "similarity.first"] <- "mean13" #similarity.first was the mean of the pair for the first temporder so mean13
names(AsIndata_wide)[names(AsIndata_wide) == "similarity.second"] <- "mean24"
#Create unique pair name by concatening first colour with second colour
AsIndata_wide$pair13 <- str_c(AsIndata_wide$hex1.first, '',AsIndata_wide$hex2.first)
AsIndata_wide$pair24 <- str_c(AsIndata_wide$hex1.second, '',AsIndata_wide$hex2.second)
#calculating Asymmetry Index as per Simplified formula (M13 -M24)
AsIndata_wide$AsIn13 <- (AsIndata_wide$mean13 - AsIndata_wide$mean24)
#calculating Asymmetry Index as per Simplified formula (M24 -M13)
AsIndata_wide$AsIn24 <- (AsIndata_wide$mean24 - AsIndata_wide$mean13)
}
#GET AsIn in Colourpairs DATAFRAME
{
get_mean_asymmetry <- function(z){
a<-subset(AsIndata_wide, pair13==z) #getting all the instance in pair13 matching the pair of hexcodes
a<- a["AsIn13"] #only keeping the asymmetry score of interest
names(a)[names(a)== "AsIn13"] <- "AsIn" #rename to be able to rbind with b
b<-subset(AsIndata_wide, pair24==z) #repeating with pair24
b<- b["AsIn24"] # again keeping only AsIn24
names(b)[names(b)== "AsIn24"] <- "AsIn" #rename to be able to rbind with a
c <-rbind(a, b)
AsIn <- mean(c$AsIn)
return(AsIn)
}
colourpairs$mean.asymmetry<-lapply(colourpairs$pair, get_mean_asymmetry) #apply function
colourpairs$mean.asymmetry<- as.numeric(colourpairs$mean.asymmetry) #make it numeric
}
#GET AsIn variance
get_var_asymmetry <- function(z) {  #makes a temporary dataframe with all the similarity ratings for one colourpair (x = row in mean_similarity ie. one per colourpair)
a<-subset(AsIndata_wide, pair13==z) #getting all the instance in pair13 matching the pair of hexcodes
a<- a["AsIn13"] #only keeping the asymmetry score of interest
names(a)[names(a)== "AsIn13"] <- "AsIn" #rename to be able to rbind with b
b<-subset(AsIndata_wide, pair24==z) #repeating with pair24
b<- b["AsIn24"] # again keeping only AsIn24
names(b)[names(b)== "AsIn24"] <- "AsIn" #rename to be able to rbind with a
c <-rbind(a, b) #combine both subset to have complete
var.AsIn <- var(c$AsIn)
return(var.AsIn)
}
colourpairs$var.asymmetry<-lapply(colourpairs$pair, get_var_asymmetry) #apply function
colourpairs$var.asymmetry<- as.numeric(colourpairs$var.asymmetry) #make it numeric
colourpairs$sem.asymmetry <- sqrt(colourpairs$var.asymmetry)/sqrt(colourpairs$pair_hitcount)
#plot with colour pairs CORRECT ONE TO USE
ggplot(colourpairs) +
aes(x = hex1, y = hex2, fill = mean.asymmetry) +
geom_raster() +
scale_fill_distiller(palette = "PiYG") +
theme_pubr()+
theme(legend.position = "left")+
scale_x_discrete(labels=block_rep) + scale_y_discrete(labels=block_rep) +
theme(axis.text.x= element_text(size= 5, angle=90, colour=row.facs))+
theme(axis.text.y = element_text(size= 5, colour=row.facs))
#### MATRIX WITH ASYMMETRY VALUES #### DOES NOT WORK IF FACTORS ALREADY APPLIED
{# Create blank matrix
asym.matrix <- matrix(NA, ncol = 93, nrow = 93)
# setting all give colours as both row and column names
colnames(asym.matrix) <- rownames(asym.matrix) <- unique(trialdata$hex1)
# fill matrix with asymmetry index values
matrix.df.fill <- function(data,matrix.df){
for(i in 1:nrow(data)){
row <- data[i,]
matrix.df[row$hex1,row$hex2] <- row$mean.asymmetry
}
return(matrix.df)
}
asym.data_vars <- c("hex1", "hex2", "mean.asymmetry")
asym.data <- colourpairs[asym.data_vars]
asym.matrix <- matrix.df.fill(asym.data,asym.matrix)
asym.matrix.df <- as.data.frame(asym.matrix)
}
View(asym.matrix)
View(colourpairs)
#calculate mean of each column
color.names <- colnames(asym.matrix.df) #get list of colours
asym_percolour.df<- as.data.frame(color.names) #make it a dataframe
asym_percolour.df$average.asymmetry <-colMeans(asym.matrix.df) # add new variable to dataframe with mean of each column in matrix
asym_percolour.df$color.names <- with(asym_percolour.df, factor(color.names, levels = row.facs)) #make colour variable as factor for graphing
#calculate variance of each column
asym_percolour.df$Variance <- colVars(asym.matrix)
#replace NAs with zero for graphing
asym_percolour.df[is.na(asym_percolour.df)] = 0
#plot with colour pairs CORRECT ONE TO USE
ggplot(colourpairs) +
aes(x = hex1, y = hex2, fill = mean.asymmetry) +
geom_raster() +
scale_fill_distiller(palette = "PiYG") +
theme_pubr()+
theme(legend.position = "left")+
scale_x_discrete(labels=block_rep) + scale_y_discrete(labels=block_rep) +
theme(axis.text.x= element_text(size= 5, angle=90, colour=row.facs))+
theme(axis.text.y = element_text(size= 5, colour=row.facs))
#APPLY COLOUR FACTORS TO COLOURPAIRS DATAFRAME
colourpairs$hex1 <- with(colourpairs, factor(hex1, levels = row.facs))
colourpairs$hex2 <- with(colourpairs, factor(hex2, levels = row.facs))
#plot with colour pairs CORRECT ONE TO USE
ggplot(colourpairs) +
aes(x = hex1, y = hex2, fill = mean.asymmetry) +
geom_raster() +
scale_fill_distiller(palette = "PiYG") +
theme_pubr()+
theme(legend.position = "left")+
scale_x_discrete(labels=block_rep) + scale_y_discrete(labels=block_rep) +
theme(axis.text.x= element_text(size= 5, angle=90, colour=row.facs))+
theme(axis.text.y = element_text(size= 5, colour=row.facs))
#visualise average asymmetry per column
ggplot(asym_percolour.df)+
aes(x = color.names, y= average.asymmetry, fill= color.names)+
theme_pubr()+
geom_col()+
scale_x_discrete(labels=block_rep)+
scale_fill_manual(values =c(row.facs))+
guides(fill="none")+
theme(axis.title.x=element_blank(),
axis.ticks.x = element_blank(),
axis.text.x = element_blank())+
geom_hline(aes(yintercept =0))
View(asym.matrix.df)
View(asym_percolour.df)
single.colour.df <- as.data.frame(single.colour.df)
#Isolating one colour for further analysis
single.colour.df <- colourpairs[colourpairs$hex1=="#FF8F00",] #subsetting
View(single.colour.df)
ggplot(single.colour.df)+
aes(mean.asymmetry)+
geom_histogram(fill='#FF8F00')+ #make colour of histogram the colour plotted
scale_x_continuous(breaks = as.numeric(round(quantile(single.colour.df$mean.asymmetry),digits = 2)))+ #change axis to display quantile value instead of arbitrary values
labs(x = "#FF8F00")+
theme_pubr()+
theme(axis.text.x = element_text(angle = 45)) #angle the text to make easier to read, not yet working
ggplot(single.colour.df) +
aes(x = hex2, fill = pair_hitcount, y = mean.asymmetry) +
geom_col() +
scale_fill_viridis_c(option = "plasma", direction = 1) +
labs(
x = "Colour compared to",
y = "Asymmetry Index (averaged across participants)",
title = "Asymmetries of #FF8F00",
fill = "Number of partcipants"
) +
theme_pubr()+
scale_x_discrete(labels=block_rep)+
theme(axis.text.x= element_text(size= 5, angle=90, colour=row.facs))
single.colour.df$hex2 <- with(single.colour.df, factor(hex2, levels = row.facs)) #make colour variable as factor for graphing
ggplot(single.colour.df)+
aes(mean.asymmetry)+
geom_histogram(fill='#FF8F00')+ #make colour of histogram the colour plotted
scale_x_continuous(breaks = as.numeric(round(quantile(single.colour.df$mean.asymmetry),digits = 2)))+ #change axis to display quantile value instead of arbitrary values
labs(x = "#FF8F00")+
theme_pubr()+
theme(axis.text.x = element_text(angle = 45)) #angle the text to make easier to read, not yet working
ggplot(single.colour.df) +
aes(x = hex2, fill = pair_hitcount, y = mean.asymmetry) +
geom_col() +
scale_fill_viridis_c(option = "plasma", direction = 1) +
labs(
x = "Colour compared to",
y = "Asymmetry Index (averaged across participants)",
title = "Asymmetries of #FF8F00",
fill = "Number of partcipants"
) +
theme_pubr()+
scale_x_discrete(labels=block_rep)+
theme(axis.text.x= element_text(size= 5, angle=90, colour=row.facs))
#Calculating rough tscore with population equal to 92 colours
asym_percolour.df$t <- NA
asym_percolour.df$t <- asym_percolour.df$average.asymmetry/(sqrt(asym_percolour.df$Variance)/sqrt(92))
#asym_percolour.df$t <- abs(asym_percolour.df$t)
asym_percolour.df[is.na(asym_percolour.df)] = 0 #for graphing
mean(single.colour.df$mean.asymmetry) #calculating mean
var(single.colour.df$mean.asymmetry) #caculating variance
mean(single.colour.df$mean.asymmetry)/(sqrt(var(single.colour.df$mean.asymmetry))/sqrt(92)) #calculating tscore
View(single.colour.df)
#distribution of asymmetry values for one colour
ggplot(single.colour.df)+
aes(mean.asymmetry)+
geom_histogram(fill= unique(single.colour.df$hex1))+ #make colour of histogram the colour plotted
scale_x_continuous(breaks = as.numeric(round(quantile(single.colour.df$mean.asymmetry),digits = 2)))+ #change axis to display quantile value instead of arbitrary values
labs(x = paste(unique(single.colour.df$hex1)))+
theme_pubr()+
theme(axis.text.x = element_text(angle = 45)) #angle the text to make easier to read, not yet working
#Visualisation of asymmetry index for one colour only against all other colours to see impact of hitcount
ggplot(single.colour.df) +
aes(x = hex2, fill = pair_hitcount, y = mean.asymmetry) +
geom_col() +
scale_fill_viridis_c(option = "plasma", direction = 1) +
labs(
x = "Colour compared to",
y = "Asymmetry Index (averaged across participants)",
title = paste("Asymmetries of ", unique(single.colour.df$hex1), sep = ""),
fill = "Number of partcipants"
) +
theme_pubr()+
scale_x_discrete(labels=block_rep)+
theme(axis.text.x= element_text(size= 5, angle=90, colour=row.facs))
#Visualisation of asymmetry index for one colour only against all other colours to see impact of variance
ggplot(single.colour.df) +
aes(x = hex2, fill = var.asymmetry, y = mean.asymmetry) +
geom_col() +
scale_fill_viridis_c(option = "plasma", direction = 1) +
labs(
x = "Colour compared to",
y = "Asymmetry Index (averaged across participants)",
title = paste("Asymmetries of ", unique(single.colour.df$hex1), sep = ""),
fill = "Number of partcipants"
) +
theme_pubr()+
scale_x_discrete(labels=block_rep)+
theme(axis.text.x= element_text(size= 5, angle=90, colour=row.facs))
#Visualisation of asymmetry index for one colour only against all other colours to see impact of variance
ggplot(single.colour.df) +
aes(x = hex2, fill = var.asymmetry, y = mean.asymmetry) +
geom_col() +
scale_fill_viridis_c(option = "plasma", direction = 1) +
labs(
x = "Colour compared to",
y = "Asymmetry Index (averaged across participants)",
title = paste("Asymmetries of ", unique(single.colour.df$hex1), sep = ""),
fill = "Variance") +
theme_pubr()+
scale_x_discrete(labels=block_rep)+
theme(axis.text.x= element_text(size= 5, angle=90, colour=row.facs))
#Visualisation of asymmetry index for one colour only against all other colours to see impact of variance
ggplot(single.colour.df) +
aes(x = hex2, fill = var.asymmetry, y = mean.asymmetry) +
geom_col() +
scale_fill_viridis_c(option = "plasma") +
labs(
x = "Colour compared to",
y = "Asymmetry Index (averaged across participants)",
title = paste("Asymmetries of ", unique(single.colour.df$hex1), sep = ""),
fill = "Variance") +
theme_pubr()+
scale_x_discrete(labels=block_rep)+
theme(axis.text.x= element_text(size= 5, angle=90, colour=row.facs))
#Visualisation of asymmetry index for one colour only against all other colours to see impact of variance
ggplot(single.colour.df) +
aes(x = hex2, fill = var.asymmetry, y = mean.asymmetry) +
geom_col() +
scale_fill_viridis_c(option = "plasma", direction = 2) +
labs(
x = "Colour compared to",
y = "Asymmetry Index (averaged across participants)",
title = paste("Asymmetries of ", unique(single.colour.df$hex1), sep = ""),
fill = "Variance") +
theme_pubr()+
scale_x_discrete(labels=block_rep)+
theme(axis.text.x= element_text(size= 5, angle=90, colour=row.facs))
#Visualisation of asymmetry index for one colour only against all other colours to see impact of variance
ggplot(single.colour.df) +
aes(x = hex2, fill = var.asymmetry, y = mean.asymmetry) +
geom_col() +
scale_fill_viridis_c(option = "plasma", direction = -1) +
labs(
x = "Colour compared to",
y = "Asymmetry Index (averaged across participants)",
title = paste("Asymmetries of ", unique(single.colour.df$hex1), sep = ""),
fill = "Variance") +
theme_pubr()+
scale_x_discrete(labels=block_rep)+
theme(axis.text.x= element_text(size= 5, angle=90, colour=row.facs))
View(colourpairs)
# density plot of mean asymmetry
ggplot(colourpairs)+
aes(x=mean.asymmetry)+
geom_density()+
theme_pubr()+
geom_vline(xintercept = 0, colour ="grey")
#Visualisation of asymmetry index for one colour only against all other colours to see impact of SEM
ggplot(single.colour.df) +
aes(x = hex2, fill = sem.asymmetry, y = mean.asymmetry) +
geom_col() +
scale_fill_viridis_c(option = "plasma", direction = -1) +
labs(
x = "Colour compared to",
y = "Asymmetry Index (averaged across participants)",
title = paste("Asymmetries of ", unique(single.colour.df$hex1), sep = ""),
fill = "Variance") +
theme_pubr()+
scale_x_discrete(labels=block_rep)+
theme(axis.text.x= element_text(size= 5, angle=90, colour=row.facs))
#Visualisation of asymmetry index for one colour only against all other colours to see impact of SEM
ggplot(single.colour.df) +
aes(x = hex2, fill = sem.asymmetry, y = mean.asymmetry) +
geom_col() +
scale_fill_viridis_c(option = "plasma", direction = -1) +
labs(
x = "Colour compared to",
y = "Asymmetry Index (averaged across participants)",
title = paste("Asymmetries of ", unique(single.colour.df$hex1), sep = ""),
fill = "Standard Error of Mean asymmetry") +
theme_pubr()+
scale_x_discrete(labels=block_rep)+
theme(axis.text.x= element_text(size= 5, angle=90, colour=row.facs))
#Visualisation of asymmetry index for one colour only against all other colours to see impact of SEM
ggplot(single.colour.df) +
aes(x = hex2, fill = sem.asymmetry, y = mean.asymmetry) +
geom_col() +
scale_fill_viridis_c(option = "plasma", direction = 1) +
labs(
x = "Colour compared to",
y = "Asymmetry Index (averaged across participants)",
title = paste("Asymmetries of ", unique(single.colour.df$hex1), sep = ""),
fill = "Standard Error of Mean asymmetry") +
theme_pubr()+
scale_x_discrete(labels=block_rep)+
theme(axis.text.x= element_text(size= 5, angle=90, colour=row.facs))
#Visualisation of asymmetry index for one colour only against all other colours to see impact of SEM
ggplot(single.colour.df) +
aes(x = hex2, fill = sem.asymmetry, y = mean.asymmetry) +
geom_col() +
scale_fill_viridis_c(option = "plasma", direction = 1) +
labs(
x = "Colour compared to",
y = "Asymmetry Index (averaged across participants)",
title = paste("Asymmetries of ", unique(single.colour.df$hex1), sep = ""),
fill = "SEM asymmetry") +
theme_pubr()+
scale_x_discrete(labels=block_rep)+
theme(axis.text.x= element_text(size= 5, angle=90, colour=row.facs))
## T-TESTING UNCORRECTED --- WIP
colourpairs$t <- NA
colourpairs$t <- colourpairs$mean.asymmetry/(sqrt(colourpairs$var.asymmetry)/sqrt(colourpairs$pair_hitcount))
#Isolating one colour for further analysis
single.colour.df <- colourpairs[colourpairs$hex1=="#FF8F00",] #subsetting
mean(single.colour.df$mean.asymmetry) #calculating mean for sanity check
var(single.colour.df$mean.asymmetry) #caculating variance for sanity check
mean(single.colour.df$mean.asymmetry)/(sqrt(var(single.colour.df$mean.asymmetry))/sqrt(92)) #calculating tscore for sanity check
single.colour.df <- as.data.frame(single.colour.df)
single.colour.df$hex2 <- with(single.colour.df, factor(hex2, levels = row.facs)) #make colour variable as factor for graphing
#Visualisation of asymmetry index for one colour only against all other colours to see Significance (tscore)
ggplot(single.colour.df) +
aes(x = hex2, fill = t, y = mean.asymmetry) +
geom_col() +
scale_fill_viridis_c(option = "plasma", direction = 1) +
labs(
x = "Colour compared to",
y = "Asymmetry Index (averaged across participants)",
title = paste("Asymmetries of ", unique(single.colour.df$hex1), sep = ""),
fill = "t-score") +
theme_pubr()+
scale_x_discrete(labels=block_rep)+
theme(axis.text.x= element_text(size= 5, angle=90, colour=row.facs))
#Calculating rough tscore with population equal to 92 colours
asym_percolour.df$t <- NA
asym_percolour.df$t <- asym_percolour.df$average.asymmetry/(sqrt(asym_percolour.df$Variance)/sqrt(92))
#asym_percolour.df$t <- abs(asym_percolour.df$t)
asym_percolour.df[is.na(asym_percolour.df)] = 0 #for graphing
#visualise asymmetry tscore per column
ggplot(asym_percolour.df)+
aes(x = color.names, y= t, fill= color.names)+
theme_pubr()+
geom_col()+
scale_x_discrete(labels=block_rep)+
scale_fill_manual(values =c(row.facs))+
guides(fill="none")+
theme(axis.text.x= element_text(size= 5, angle=90, colour=row.facs))
#visualise asymmetry variance per column
ggplot(asym_percolour.df)+
aes(x = color.names, y= Variance, fill= color.names)+
theme_pubr()+
geom_col()+
scale_x_discrete(labels=block_rep)+
scale_fill_manual(values =c(row.facs))+
guides(fill="none")+
theme(axis.text.x= element_text(size= 5, angle=90, colour=row.facs))
