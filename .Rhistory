trialdata <- cbind(trialdata, circle1_df, circle2_df)
{
trialdata_passes<-trialdata
names(trialdata_passes)[names(trialdata_passes) == 'similarity'] <- 'firstpass_similarity'
trialdata_passes$secondpass_similarity <- NA
names(trialdata_passes)[names(trialdata_passes) == 'response_time'] <- 'firstpass_responsetime'
trialdata_passes$secondpass_responsetime<-NA
for (x in 0:(nrow(participants_complete)-1)) { #put 2nd pass data in that column (x = row number in participants_complete)
trialdata_passes$secondpass_similarity[((x*324)+1):((x*324)+162)] <- trialdata_passes$firstpass_similarity[((x*324)+163):((x*324)+324)]
trialdata_passes$secondpass_responsetime[((x*324)+1):((x*324)+162)] <- trialdata_passes$firstpass_responsetime[((x*324)+163):((x*324)+324)]
}
#delete extra rows
trialdata_passes <- na.omit(trialdata_passes)
#make a column with the mean similarity value from the two passes
means<-data.frame(similarity=rowMeans(trialdata_passes[,c("firstpass_similarity", "secondpass_similarity")]))
trialdata_passes<-cbind(trialdata_passes,means)
}
{
#make a dataframe to store correlation values
pass_correlation <- data.frame(participants_complete$participant_id)
names(pass_correlation)[names(pass_correlation) == 'participants_complete.participant_id'] <- 'participant'
pass_correlation$pearson<- NA
pass_correlation$spearman<- NA
#put correlation values into dataframe
#x <- participant id
getpearson<-function(z){
temp_df <- subset(trialdata_passes,participant==z)
pearson <- cor(x=temp_df$firstpass_similarity, y=temp_df$secondpass_similarity, method="pearson")
return(pearson)
}
getspearman<-function(z){
temp_df <- subset(trialdata_passes,participant==z)
spearman <- cor(x=temp_df$firstpass_similarity, y=temp_df$secondpass_similarity, method="spearman")
return(spearman)
}
pass_correlation$pearson<-lapply(participants_complete$participant, getpearson) #apply fn
pass_correlation$spearman<-lapply(participants_complete$participant, getspearman)
#make correlation numeric for graphing
pass_correlation$pearson<-as.numeric(pass_correlation$pearson)
pass_correlation$spearman<-as.numeric(pass_correlation$spearman)
#if error: check trialdata_passes that resulted in NA correlation
unique(unlist (lapply (pass_correlation, function (x) which (is.na (x)))))
#trialdata_passes[trialdata_passes$participant == '61652222bfd9351c91a6585a',]
#drop rows with NA correlation #
pass_correlation<- na.omit(pass_correlation)
#covert rho to fisher's z
#x=rho value
get_fisherz <-function(x){
variable<-(0.5*(log(1+x) - log(1-x)) )
return(variable)
}
pass_correlation$fisherz <- lapply(pass_correlation[,"pearson"], get_fisherz) #apply function
pass_correlation$fisherz<-as.numeric(pass_correlation$fisherz)
}
{
#save mean fisherz
mean_z<- round(mean(pass_correlation$fisherz), 2)
sd_z<- round(sd(pass_correlation$fisherz), 2)
#Participants below 2 standard deviation of mean correlation
outsiders <- pass_correlation[pass_correlation$fisherz<(mean_z-2*sd_z),]
pass_correlation <- subset(pass_correlation, !participant %in% outsiders$participant)
trialdata <- subset(trialdata, !participant %in% participants_incomplete$participant_id)
}
#get unique hex arrangements
colourpairs <- unique(trialdata_passes[ , c("hex1", "hex2")])
#Create unique pair name by concatening first colour with second colour
colourpairs$pair <- str_c(colourpairs$hex1, '',colourpairs$hex2)
trialdata_passes$pairofcolour <- str_c(trialdata_passes$hex1, '',trialdata_passes$hex2)
#adding count of colour pairs
get_pair_hitcount<-function(x){ #get number of hits on pair of colour (x = colourpair)
pair_hitcount<-sum(trialdata_passes$pairofcolour == x)
return(pair_hitcount)
}
colourpairs$pair_hitcount <-lapply(colourpairs$pair, get_pair_hitcount)
colourpairs$pair_hitcount <- as.integer(colourpairs$pair_hitcount)
ggplot(colourpairs) +
aes(x = hex1, y = hex2, fill= pair_hitcount) +
geom_raster() +
theme_pubr()+
theme(axis.text.x=element_text(angle=90,hjust=1, size=7), axis.text.y = element_text(size = 7))
#heatmap of hitcount (the more a pair is tested, the 'hotter' it gets)
ggplot(colourpairs) +
aes(x = hex1, y = hex2, fill= pair_hitcount) +
geom_raster() +
theme_pubr()+
theme(axis.text.x=element_text(angle=90,hjust=1, size=7), axis.text.y = element_text(size = 7))+
scale_fill_gradient(low = "grey", high = "black", na.value = "green")
#heatmap of hitcount (the more a pair is tested, the 'hotter' it gets)
ggplot(colourpairs) +
aes(x = hex1, y = hex2, fill= pair_hitcount) +
geom_raster() +
theme_pubr()+
theme(axis.text.x=element_text(angle=90,hjust=1, size=7), axis.text.y = element_text(size = 7))+
scale_fill_gradient2(low = "red", mid= "yellow", high = "green", midpoint= 10, na.value = "green")
#heatmap of hitcount (the more a pair is tested, the 'hotter' it gets)
ggplot(colourpairs) +
aes(x = hex1, y = hex2, fill= pair_hitcount) +
geom_raster() +
theme_pubr()+
theme(axis.text.x=element_text(angle=90,hjust=1, size=7), axis.text.y = element_text(size = 7))+
scale_fill_gradient2(low = "red", mid= "yellow", high = "green", midpoint= 15, na.value = "green")
get_mean_similarity <- function(z){
a<-subset(trialdata_passes, pairofcolour==z) #similarity with exact hex match
mean<-mean(a$similarity)
return(mean)
}
colourpairs$mean.similarity<-lapply(colourpairs$pair, get_mean_similarity)
colourpairs$mean.similarity<- as.numeric(colourpairs$mean.similarity)
View(colourpairs)
#VISUALISE MEAN SIMILARITY
{ggplot(colourpairs) +
aes(x = hex1, y = hex2, fill = mean.similarity) +
geom_raster() +
scale_fill_gradientn(colors = rainbow(7),breaks= c(0,1,2,3,4,5,6,7))+
theme_pubr()+
theme(axis.text.x= element_text(size= 7, angle=90, colour=sort(unique(colourpairs$hex1))))+
theme(axis.text.y = element_text(size= 7, colour=sort(unique(colourpairs$hex2))))
}
#MAKE DATAFRAME WITH MEAN SIMILARITY PER COLOUR PAIR (AB==BA)
{mean_similarity<-colourpairs
mean_similarity$meanas<-NA
for (x in 1:nrow(mean_similarity)) {  #makes a temporary dataframe with all the similarity ratings for one colourpair (x = row in mean_similarity ie. one per colourpair)
a<-subset(trialdata_passes,trialdata_passes$hex1==mean_similarity$hex1[x] & trialdata_passes$hex2==mean_similarity$hex2[x], c(firstpass_similarity, secondpass_similarity)) #similarity with exact hex match
b<-subset(trialdata_passes,trialdata_passes$hex1==mean_similarity$hex2[x] & trialdata_passes$hex2==mean_similarity$hex1[x], c(firstpass_similarity, secondpass_similarity)) #similarity with flipped hex order
c<-rbind(a, b) #all similarty ratings for colour pair x
mean_similarity$meanas[x]<-mean(as.matrix(c))
}
}
{
mean_variance<-colourpairs
mean_variance$var<-NA
for (x in 1:nrow(mean_variance)) {  #makes a temporary dataframe with all the similarity ratings for one colourpair (x = row in mean_similarity ie. one per colourpair)
a<-subset(trialdata,trialdata$hex1==mean_variance$hex1[x] & trialdata$hex2==mean_variance$hex2[x], c(similarity)) #similarity with exact hex match
b<-subset(trialdata,trialdata$hex1==mean_variance$hex2[x] & trialdata$hex2==mean_variance$hex1[x], c(similarity)) #similarity with flipped hex order
c<-rbind(a, b) #all similarty ratings for colour pair x
mean_variance$var[x]<-var(c)
}
ggplot(mean_variance) +
aes(x = hex1, y = hex2, fill = var) +
geom_raster() +
scale_fill_gradient(name="Variance" ,low = "grey", high = "black", na.value = "green")+
ggthemes::theme_base()+
theme(axis.text.x= element_text(size= 6, angle=90, colour=sort(unique(mean_variance$hex1))))+
theme(axis.text.y = element_text(size= 6, colour=sort(unique(mean_variance$hex2))))+
theme(legend.position = "right")+
labs(x= "Colour presented first", y= "Colour presented second")
}
View(mean_variance)
View(mean_variance)
mean_variance$sem <- sqrt(mean_variance$var)/sqrt(mean_variance$pair_hitcount)
mean_asymmetry<-mean_variance
mean_asymmetry$meanas<-NA
for (x in 1:nrow(mean_asymmetry)) {  #makes a temporary dataframe with all the similarity ratings for one colourpair (x = row in mean_similarity ie. one per colourpair)
a<-subset(AsIndata_wide,AsIndata_wide$hex1.first==mean_asymmetry$hex1[x] & AsIndata_wide$hex1.second==mean_asymmetry$hex2[x], c(AsIn)) #similarity with exact hex match
b<-subset(AsIndata_wide,AsIndata_wide$hex1.first==mean_asymmetry$hex2[x] & AsIndata_wide$hex1.second==mean_asymmetry$hex1[x], c(AsIn)) #similarity with flipped hex order
c<-rbind(a, b) #all similarty ratings for colour pair x
mean_asymmetry$meanas[x]<-mean(as.matrix(c))
}
#MAKE DATAFRAME WITH ASYMMETRY INDEX (AsIn) for each participant
{
#Calculating absolute difference between first and second pass similatirity ratings
trialdata_passes$abs <- abs(trialdata_passes$firstpass_similarity-trialdata_passes$secondpass_similarity)
#Creating unique ID for each pair by combining participant ID and Colourpair
trialdata_passes$Colourpairperparticipant <- str_c(trialdata_passes$participant, '',trialdata_passes$Colourpair)
#selecting variables for asymmetry analysis
AsIndata_vars <- c("participant", "Colourpair", "Temporder", "hex1", "hex2", "similarity", "abs", "Colourpairperparticipant")
#making dataframe
AsIndata <- trialdata_passes[AsIndata_vars]
#changing to wide so that One row per colour pair per participant (4 ratings per row, first and second pass and reverse order)
AsIndata_wide <- reshape(AsIndata, idvar = "Colourpairperparticipant", timevar = "Temporder", direction = "wide")
#calculating Asymmetry Index as per Nao's formula (M13 -M24)/((A13+A24)+1)
AsIndata_wide$AsIn <- (AsIndata_wide$similarity.first - AsIndata_wide$similarity.second)/
((AsIndata_wide$abs.first + AsIndata_wide$abs.second) + 1)
#Create unique pair name by concatening first colour with second colour
AsIndata_wide$pair <- str_c(AsIndata_wide$hex1.first, '',AsIndata_wide$hex1.second)
#GET AsIn in Colourpairs DATAFRAME
get_mean_asymmetry <- function(z){
a<-subset(AsIndata_wide, pair==z) #similarity with exact hex match
mean<-mean(a$AsIn)
return(mean)
}
colourpairs$mean.asymmetry<-lapply(colourpairs$pair, get_mean_asymmetry)
colourpairs$mean.asymmetry<- as.numeric(colourpairs$mean.asymmetry)
test <- subset(colourpairs, is.na(colourpairs$mean.asymmetry))
test <- subset(AsIndata_wide, is.na(AsIndata_wide$AsIn))
}
for (x in 1:nrow(mean_asymmetry)) {  #makes a temporary dataframe with all the similarity ratings for one colourpair (x = row in mean_similarity ie. one per colourpair)
a<-subset(AsIndata_wide,AsIndata_wide$hex1.first==mean_asymmetry$hex1[x] & AsIndata_wide$hex1.second==mean_asymmetry$hex2[x], c(AsIn)) #similarity with exact hex match
b<-subset(AsIndata_wide,AsIndata_wide$hex1.first==mean_asymmetry$hex2[x] & AsIndata_wide$hex1.second==mean_asymmetry$hex1[x], c(AsIn)) #similarity with flipped hex order
c<-rbind(a, b) #all similarty ratings for colour pair x
mean_asymmetry$meanas[x]<-mean(as.matrix(c))
}
#FUNNEL PLOT Asymmetry x SEM
ggplot(mean_asymmetry) +
aes(y = meanas, x = sem) +
geom_point(position = "jitter") +
geom_hline(yintercept = 0, colour = "red")+
theme_pubr()
#FUNNEL PLOT Asymmetry x SEM
ggplot(mean_asymmetry) +
aes(y = meanas, x = sem) +
geom_point() +
geom_hline(yintercept = 0, colour = "red")+
theme_pubr()
#FUNNEL PLOT Asymmetry x SEM
ggplot(mean_asymmetry) +
aes(y = meanas, x = sem) +
geom_point() +
geom_hline(yintercept = 0, colour = "red")+
geom_abline(slope = .45, intercept = 0, colour ="red")+
theme_pubr()
#FUNNEL PLOT Asymmetry x SEM
ggplot(mean_asymmetry) +
aes(y = meanas, x = sem) +
geom_point() +
geom_hline(yintercept = 0, colour = "red")+
geom_abline(slope = .45, intercept = 0, colour ="red")+
geom_abline(slope = -.45, intercept = 0, colour ="red")+
theme_pubr()
#FUNNEL PLOT Asymmetry x SEM
ggplot(mean_asymmetry) +
aes(y = meanas, x = sem) +
geom_point() +
geom_hline(yintercept = 0, colour = "red")+
geom_abline(slope = .45, intercept = 0, colour ="red")+
geom_abline(slope = -.45, intercept = 0, colour ="red")+
geom_abline(slope = .6, intercept = 0, colour ="orange")+
theme_pubr()
#FUNNEL PLOT Asymmetry x SEM
ggplot(mean_asymmetry) +
aes(y = meanas, x = sem) +
geom_point() +
geom_hline(yintercept = 0, colour = "red")+
geom_abline(slope = .45, intercept = 0, colour ="red")+
geom_abline(slope = -.45, intercept = 0, colour ="red")+
geom_abline(slope = .9, intercept = 0, colour ="orange")+
theme_pubr()
#FUNNEL PLOT Asymmetry x SEM
ggplot(mean_asymmetry) +
aes(y = meanas, x = sem) +
geom_point() +
geom_hline(yintercept = 0, colour = "red")+
geom_abline(slope = .45, intercept = 0, colour ="red")+
geom_abline(slope = -.45, intercept = 0, colour ="red")+
geom_abline(slope = .9, intercept = 0, colour ="orange")+
geom_abline(slope = -.9, intercept = 0, colour ="orange")+
theme_pubr()
#FUNNEL PLOT Asymmetry x SEM
ggplot(mean_asymmetry) +
aes(y = meanas, x = sem) +
geom_point() +
geom_hline(yintercept = 0, colour = "red")+
geom_abline(slope = .45, intercept = 0, colour ="red")+
geom_abline(slope = -.45, intercept = 0, colour ="red")+
geom_abline(slope = 1.2, intercept = 0, colour ="orange")+
geom_abline(slope = -1.2, intercept = 0, colour ="orange")+
theme_pubr()
#FUNNEL PLOT Asymmetry x SEM
ggplot(mean_asymmetry) +
aes(y = meanas, x = sem) +
geom_point() +
geom_hline(yintercept = 0, colour = "red")+
geom_abline(slope = .45, intercept = 0, colour ="red")+
geom_abline(slope = -.45, intercept = 0, colour ="red")+
geom_abline(slope = 2, intercept = 0, colour ="orange")+
geom_abline(slope = -1.2, intercept = 0, colour ="orange")+
theme_pubr()
#FUNNEL PLOT Asymmetry x SEM
ggplot(mean_asymmetry) +
aes(y = meanas, x = sem) +
geom_point() +
geom_hline(yintercept = 0, colour = "red")+
geom_abline(slope = .45, intercept = 0, colour ="red")+
geom_abline(slope = -.45, intercept = 0, colour ="red")+
geom_abline(slope = 3, intercept = 0, colour ="orange")+
geom_abline(slope = -4, intercept = 0, colour ="orange")+
theme_pubr()
View(mean_asymmetry)
#FUNNEL PLOT Asymmetry x SEM
ggplot(mean_asymmetry) +
aes(y = meanas, x = sem) +
geom_point(position = "jitter") +
geom_hline(yintercept = 0, colour = "red")+
geom_hline(yintercept = -1.5, colour = "red")+
theme_pubr()
#MAKE DATAFRAME WITH MEAN SIMILARITY PER COLOUR PAIR (AB==BA)
{median_similarity<-colourpairs
median_similarity$median<-NA
for (x in 1:nrow(mediaan_similarity)) {  #makes a temporary dataframe with all the similarity ratings for one colourpair (x = row in mean_similarity ie. one per colourpair)
a<-subset(trialdata_passes,trialdata_passes$hex1==median_similarity$hex1[x] & trialdata_passes$hex2==median_similarity$hex2[x], c(firstpass_similarity, secondpass_similarity)) #similarity with exact hex match
b<-subset(trialdata_passes,trialdata_passes$hex1==median_similarity$hex2[x] & trialdata_passes$hex2==median_similarity$hex1[x], c(firstpass_similarity, secondpass_similarity)) #similarity with flipped hex order
c<-rbind(a, b) #all similarty ratings for colour pair x
median_similarity$median[x]<-median(as.matrix(c))
}
}
median_similarity<-colourpairs
median_similarity$median<-NA
for (x in 1:nrow(median_similarity)) {  #makes a temporary dataframe with all the similarity ratings for one colourpair (x = row in mean_similarity ie. one per colourpair)
a<-subset(trialdata_passes,trialdata_passes$hex1==median_similarity$hex1[x] & trialdata_passes$hex2==median_similarity$hex2[x], c(firstpass_similarity, secondpass_similarity)) #similarity with exact hex match
b<-subset(trialdata_passes,trialdata_passes$hex1==median_similarity$hex2[x] & trialdata_passes$hex2==median_similarity$hex1[x], c(firstpass_similarity, secondpass_similarity)) #similarity with flipped hex order
c<-rbind(a, b) #all similarty ratings for colour pair x
median_similarity$median[x]<-median(as.matrix(c))
}
View(mean_variance)
View(median_similarity)
View(means)
#MEDIAN SIMILARITY MATRIX
{ggplot(median_similarity) +
aes(x = hex1, y = hex2, fill = median) +
geom_raster() +
scale_fill_gradientn(colors = rainbow(7),breaks= c(0,1,2,3,4,5,6,7))+
theme_pubr()+
theme(axis.text.x= element_text(size= 7, angle=90, colour=sort(unique(median_similarity$hex1))))+
theme(axis.text.y = element_text(size= 7, colour=sort(unique(median_similarity$hex2))))
}
#MEDIAN SIMILARITY MATRIX
{ggplot(median_similarity) +
aes(x = hex1, y = hex2, fill = median) +
geom_raster() +
scale_fill_gradient(low= "grey", high= "black",breaks= c(0,1,2,3,4,5,6,7))+
theme_pubr()+
theme(axis.text.x= element_text(size= 7, angle=90, colour=sort(unique(median_similarity$hex1))))+
theme(axis.text.y = element_text(size= 7, colour=sort(unique(median_similarity$hex2))))
}
## ISHIHARA
library(readxl)
IH_vars<- c("participant", "Ishi_textbox.text", "imageaddress")
#make catch data frame
IHdata<-data[IH_vars]
#remove empty cells
IHdata <- IHdata %>% drop_na()
#Scoring reference
scoringtable<- read_excel("PictureConditions.xlsx")
#inserting correct answers to participants dataframe
IHdata <- merge(IHdata, scoringtable, by= "imageaddress")
#coercing answers into numeric for efficient matching
IHdata$answer.numeric <- as.numeric(IHdata$Ishi_textbox.text)
IHdata$match <- IHdata$answer.numeric==IHdata$correctanswer
#make dataframe with IH scores
IH_perperson<- data.frame(unique(IHdata$participant))
IH_perperson<-rename(IH_perperson, participant = unique.IHdata.participant.)
get_IHscoredecimal<- function(z){
temp_df <- subset(IHdata,participant==z)
total_IH <- nrow(temp_df)
correct_IH<- nrow(subset(temp_df,Ishi_textbox.text==correctanswer))
IHscoredecimal<-format(round(correct_IH/total_IH, 2), nsmall = 2)
IHscoredecimal<-as.numeric(IHscoredecimal)
return(IHscoredecimal)
}
IH_perperson$score_decimal<-lapply(IH_perperson$participant, get_IHscoredecimal)
get_IHscorefraction<- function(z){
temp_df <- subset(IHdata,participant==z)
total_IH <- nrow(temp_df)
correct_IH<- nrow(subset(temp_df,Ishi_textbox.text==correctanswer))
IHscorefraction<-paste(correct_IH,"/",total_IH,"/", "16")
return(IHscorefraction)
}
IH_perperson$score_fraction<-lapply(IH_perperson$participant, get_IHscorefraction)
#make dataframe with IH scores
IH_perperson<- data.frame(unique(IHdata$participant))
IH_perperson<-rename(IH_perperson, participant = unique.IHdata.participant.)
#get IH correctly answered
{get_IHcorrectQs<- function(z){
temp_df <- subset(IHdata,participant==z)
correct_IH<- nrow(subset(temp_df,match==TRUE))
return(correct_IH)
}
IH_perperson$correctA<-lapply(IH_perperson$participant, get_IHcorrectQs)
IH_perperson$correctA <- as.numeric(IH_perperson$correctA)
}
#get IH questions answered
{get_IHtotal_answered<- function(z){
temp_df <- subset(IHdata,participant==z)
total_IH <- nrow(temp_df)
return(total_IH)
}
IH_perperson$total_answered<-lapply(IH_perperson$participant, get_IHtotal_answered)
IH_perperson$total_answered <- as.numeric(IH_perperson$total_answered)
}
#this participant submitted two files
IH_perperson <- subset(IH_perperson,!participant == "61716a16c157db249e36fc46")
IH_perperson <- subset(IH_perperson,!participant == "614deecf67f2c8ccfe3df23b")
#Distribution of IH scores
ggplot(IH_perperson, aes(correctA)) +
geom_histogram() +
scale_x_continuous(breaks = as.numeric(round(quantile(IH_perperson$correctA),digits = 2))) +
theme_pubr() +
theme(axis.line = element_blank())+
geom_rangeframe()+
labs(x="Ishihara score",
title= "Histogram of Ishihara score")
#below threshold of normal colour vision
IH_perperson.low <- subset(IH_perperson, correctA <14)
#get catch score
get_catchscore<- function(z){
temp_df <- subset(catch_perperson,participant==z)
catchdecimal <- as.numeric(temp_df$score_decimal)
return(catchdecimal)
}
IH_perperson$catchdecimal<- lapply(IH_perperson$participant, get_catchscore)
#plot catch vs lowIshihara
ggplot(IH_perperson, aes(correctA, catchdecimal))+
geom_point()
IH_perperson$catchdecimal <- as.numeric(IH_perperson$catchdecimal)
#plot catch vs lowIshihara
ggplot(IH_perperson, aes(correctA, catchdecimal))+
geom_point()
#plot
ggplot(IH_perperson, aes(correctA, catchdecimal))+
geom_point(position = "jitter")+
geom_point(IH_perperson.low, aes(correctA, catchdecimal))
#showing
ggplot(IH_perperson, aes(correctA, catchdecimal))+
geom_point(aes(correctA < 14, colour= "red"))+
scale_y_continuous(breaks = as.numeric(round(quantile(IH_perperson$catchdecimal),digits = 2))) +
scale_x_continuous(breaks = as.numeric(round(quantile(IH_perperson$correctA),digits = 2))) +
theme_pubr() +
theme(axis.line = element_blank())+
geom_rangeframe()
#Distribution of IH scores
ggplot(IH_perperson, aes(correctA)) +
geom_histogram() +
scale_x_continuous(breaks = as.numeric(round(quantile(IH_perperson$correctA),digits = 2))) +
theme_pubr() +
theme(axis.line = element_blank())+
geom_rangeframe()+
labs(x="Ishihara score",
title= "Histogram of Ishihara score")
#plot
ggplot(IH_perperson, aes(correctA, catchdecimal))+
geom_point(position = "jitter")+
scale_y_continuous(breaks = as.numeric(round(quantile(IH_perperson$catchdecimal),digits = 2))) +
scale_x_continuous(breaks = as.numeric(round(quantile(IH_perperson$correctA),digits = 2))) +
theme_pubr() +
theme(axis.line = element_blank())+
geom_rangeframe()
#plot catch vs lowIshihara
ggplot(IH_perperson, aes(correctA, catchdecimal))+
geom_point()
#make numeric to be able to plot
IH_perperson$catchdecimal <- as.numeric(IH_perperson$catchdecimal)
#showing
ggplot(IH_perperson, aes(correctA, catchdecimal))+
geom_point(aes(correctA < 14, colour= "red"))+
scale_y_continuous(breaks = as.numeric(round(quantile(IH_perperson$catchdecimal),digits = 2))) +
scale_x_continuous(breaks = as.numeric(round(quantile(IH_perperson$correctA),digits = 2))) +
theme_pubr() +
theme(axis.line = element_blank())+
geom_rangeframe()
#showing
ggplot(IH_perperson, aes(correctA, catchdecimal))+
geom_point()+
geom_point(data = IH_perperson.low, aes(correctA, catchdecimal), colour ="red")+
scale_y_continuous(breaks = as.numeric(round(quantile(IH_perperson$catchdecimal),digits = 2))) +
scale_x_continuous(breaks = as.numeric(round(quantile(IH_perperson$correctA),digits = 2))) +
theme_pubr() +
theme(axis.line = element_blank())+
geom_rangeframe()
View(IH_perperson.low)
IH_perperson.low$catchdecimal<- lapply(IH_perperson.low$participant, get_catchscore)
IH_perperson.low$catchdecimal <- as.numeric(IH_perperson.low$catchdecimal)
#showing
ggplot(IH_perperson, aes(correctA, catchdecimal))+
geom_point()+
geom_point(data = IH_perperson.low, aes(correctA, catchdecimal), colour ="red")+
scale_y_continuous(breaks = as.numeric(round(quantile(IH_perperson$catchdecimal),digits = 2))) +
scale_x_continuous(breaks = as.numeric(round(quantile(IH_perperson$correctA),digits = 2))) +
theme_pubr() +
theme(axis.line = element_blank())+
geom_rangeframe()
View(participants_incomplete)
#showing all participants with low IH in red
ggplot(IH_perperson, aes(correctA, catchdecimal))+
geom_point(position = "jitter")+
geom_point(data = IH_perperson.low, aes(correctA, catchdecimal), colour ="red")+
scale_y_continuous(breaks = as.numeric(round(quantile(IH_perperson$catchdecimal),digits = 2))) +
scale_x_continuous(breaks = as.numeric(round(quantile(IH_perperson$correctA),digits = 2))) +
theme_pubr() +
theme(axis.line = element_blank())+
geom_rangeframe()
View(trialdata_passes)
View(participants_complete)
View(pass_correlation)
#PLOTTING ISHIHARAxDoublepass
#get catch score
get_doublepass<- function(z){
temp_df <- subset(pass_correlation,participant==z)
pearson <- as.numeric(temp_df$pearson)
return(pearson)
}
IH_perperson$doublepass<- lapply(IH_perperson$participant, get_doublepass)
IH_perperson$doublepass <- as.numeric(IH_perperson$doublepass)
#showing all participants
ggplot(IH_perperson, aes(correctA, doublepass))+
geom_point(position = "jitter")+
scale_y_continuous(breaks = as.numeric(round(quantile(IH_perperson$doublepass),digits = 2))) +
scale_x_continuous(breaks = as.numeric(round(quantile(IH_perperson$correctA),digits = 2))) +
theme_pubr() +
theme(axis.line = element_blank())+
geom_rangeframe()
View(IH_perperson)
#showing all participants
ggplot(IH_perperson, aes(correctA, doublepass))+
geom_point(position = "jitter")+
theme_pubr()
IH_perperson.low$doublepass<- lapply(IH_perperson.low$participant, get_doublepass)
IH_perperson.low$doublepass <- as.numeric(IH_perperson.low$doublepass)
#showing all participants
ggplot(IH_perperson, aes(correctA, doublepass))+
geom_point(position = "jitter")+
geom_point(data = IH_perperson.low, aes(correctA, doublepass), colour ="red")+
theme_pubr()
