colnames(circle2_df) <- c("r2", "g2", "b2")
circle1_df<-as.data.frame(circle1_df)
circle2_df<-as.data.frame(circle2_df)
circle1_df$hex1 <- NA
circle2_df$hex2 <- NA
#rgb2hex function
rgb2hex <- function(r, g, b) {rgb(r, g, b, maxColorValue = 255)}
#Get hex in each circle dataframe
circle1_df$hex1 <- apply(circle1_df, 1, function(x) rgb2hex(x[1], x[2], x[3]))
circle2_df$hex2 <- apply(circle2_df, 1, function(x) rgb2hex(x[1], x[2], x[3]))
#bind circle colour dataframes to trialdata
trialdata <- cbind(trialdata, circle1_df, circle2_df)
}
#MAKE PASS COLUMNS IN TRIAL DATA
{
trialdata_passes<-trialdata
names(trialdata_passes)[names(trialdata_passes) == 'similarity'] <- 'firstpass_similarity'
trialdata_passes$secondpass_similarity <- NA
names(trialdata_passes)[names(trialdata_passes) == 'response_time'] <- 'firstpass_responsetime'
trialdata_passes$secondpass_responsetime<-NA
for (x in 0:(nrow(participants_complete)-1)) { #put 2nd pass data in that column (x = row number in participants_complete)
trialdata_passes$secondpass_similarity[((x*324)+1):((x*324)+162)] <- trialdata_passes$firstpass_similarity[((x*324)+163):((x*324)+324)]
trialdata_passes$secondpass_responsetime[((x*324)+1):((x*324)+162)] <- trialdata_passes$firstpass_responsetime[((x*324)+163):((x*324)+324)]
}
#delete extra rows
trialdata_passes <- na.omit(trialdata_passes)
#make a column with the mean similarity value from the two passes
means<-data.frame(similarity=rowMeans(trialdata_passes[,c("firstpass_similarity", "secondpass_similarity")]))
trialdata_passes<-cbind(trialdata_passes,means)
}
#CORRELATION DATAFRAME WITH ONE ROW PER PARTICIPANT
{
#make a dataframe to store correlation values
pass_correlation <- data.frame(participants_complete$participant_id)
names(pass_correlation)[names(pass_correlation) == 'participants_complete.participant_id'] <- 'participant'
pass_correlation$pearson<- NA
pass_correlation$spearman<- NA
#put correlation values into dataframe
#x <- participant id
getpearson<-function(z){
temp_df <- subset(trialdata_passes,participant==z)
pearson <- cor(x=temp_df$firstpass_similarity, y=temp_df$secondpass_similarity, method="pearson")
return(pearson)
}
getspearman<-function(z){
temp_df <- subset(trialdata_passes,participant==z)
spearman <- cor(x=temp_df$firstpass_similarity, y=temp_df$secondpass_similarity, method="spearman")
return(spearman)
}
pass_correlation$pearson<-lapply(participants_complete$participant, getpearson) #apply fn
pass_correlation$spearman<-lapply(participants_complete$participant, getspearman)
#make correlation numeric for graphing
pass_correlation$pearson<-as.numeric(pass_correlation$pearson)
pass_correlation$spearman<-as.numeric(pass_correlation$spearman)
#if error: check trialdata_passes that resulted in NA correlation
unique(unlist (lapply (pass_correlation, function (x) which (is.na (x)))))
#trialdata_passes[trialdata_passes$participant == '61652222bfd9351c91a6585a',]
#drop rows with NA correlation #
pass_correlation<- na.omit(pass_correlation)
#covert rho to fisher's z
#x=rho value
get_fisherz <-function(x){
variable<-(0.5*(log(1+x) - log(1-x)) )
return(variable)
}
pass_correlation$fisherz <- lapply(pass_correlation[,"pearson"], get_fisherz) #apply function
pass_correlation$fisherz<-as.numeric(pass_correlation$fisherz)
}
#save mean fisherz
mean_z<- round(mean(pass_correlation$fisherz), 2)
sd_z<- round(sd(pass_correlation$fisherz), 2)
#Participants below 2 standard deviation of mean correlation
outsiders <- pass_correlation[pass_correlation$fisherz<(mean_z-2*sd_z),]
#Participants below 2 standard deviation of mean correlation
outsiders <- pass_correlation[pass_correlation$fisherz<(mean_z-3*sd_z),]
#Participants below 2 standard deviation of mean correlation
outsiders <- pass_correlation[pass_correlation$fisherz<(mean_z-2*sd_z),]
pass_correlation <- subset(pass_correlation, !participant %in% outsiders$participant)
trialdata <- subset(trialdata, !participant %in% participants_incomplete$participant_id)
#MAKE DATAFRAME OF COLOURPAIRS
{
#get unique hex arrangements
colourpairs <- unique(trialdata_passes[ , c("hex1", "hex2")])
#remove flipped colour pairs so each colour pair is only listed once
#for (i in 2:nrow(colourpairs)) {
#  for (j in 1:(i-1)){
#    if ((colourpairs$hex1[i] == colourpairs$hex2[j])
#        && (colourpairs$hex2[i] == colourpairs$hex1[j])) {
#      colourpairs$hex1[i] = "duplicate"
#    }
#  }
#}
#colourpairs<-subset(colourpairs, !(hex1=="duplicate"))
}
#Create unique pair name by concatening first colour with second colour
colourpairs$pair <- str_c(colourpairs$hex1, '',colourpairs$hex2)
trialdata_passes$pairofcolour <- str_c(trialdata_passes$hex1, '',trialdata_passes$hex2)
#adding count of colour pairs
get_pair_hitcount<-function(x){ #get number of hits on pair of colour (x = colourpair)
pair_hitcount<-sum(trialdata_passes$pairofcolour == x)
return(pair_hitcount)
}
colourpairs$pair_hitcount <-lapply(colourpairs$pair, get_pair_hitcount)
colourpairs$pair_hitcount <- as.integer(colourpairs$pair_hitcount)
#distribution of hitcounts
ggplot(colourpairs) +
aes(x = pair_hitcount) +
geom_bar() +
theme_minimal()
esquisse:::esquisser()
View(colourpairs)
esquisse:::esquisser()
View(colourpairs)
#distribution of hitcounts
ggplot(colourpairs) +
aes(x = pair, y= pair_hitcount) +
geom_bar() +
theme_minimal()
#distribution of hitcounts
ggplot(colourpairs) +
aes(x = pair, y= pair_hitcount) +
geom_col() +
theme_minimal()
#MAKE DATAFRAME WITH MEAN SIMILARITY PER COLOUR PAIR MAINTAINING DIRECTIONNALITY (AB=/=BA)
{
#mean_similarity<-colourpairs
#mean_similarity$mean<-NA
#for (x in 1:nrow(mean_similarity)) {#  #makes a temporary dataframe with all the similarity ratings for one colourpair (x = row in mean_similarity ie. one per colourpair)
a<-subset(trialdata_passes,trialdata_passes$hex1==mean_similarity$hex1[x] & trialdata_passes$hex2==mean_similarity$hex2[x], c(firstpass_similarity, secondpass_similarity)) #similarity with exact hex match
b<-subset(trialdata_passes,trialdata_passes$hex1==mean_similarity$hex2[x] & trialdata_passes$hex2==mean_similarity$hex1[x], c(firstpass_similarity, secondpass_similarity)) #similarity with flipped hex order
c<-rbind(a, b) #all similarty ratings for colour pair x
mean_similarity$mean[x]<-mean(as.matrix(c))
#}
get_mean_similarity <- function(z){
a<-subset(trialdata_passes, pairofcolour==z) #similarity with exact hex match
mean<-mean(a$similarity)
return(mean)
}
colourpairs$mean.similarity<-lapply(colourpairs$pair, get_mean_similarity)
colourpairs$mean.similarity<- as.numeric(colourpairs$mean.similarity)
}
get_mean_similarity <- function(z){
a<-subset(trialdata_passes, pairofcolour==z) #similarity with exact hex match
mean<-mean(a$similarity)
return(mean)
}
colourpairs$mean.similarity<-lapply(colourpairs$pair, get_mean_similarity)
colourpairs$mean.similarity<- as.numeric(colourpairs$mean.similarity)
#MAKE DATAFRAME WITH MEAN VARIANCE PER COLOUR PAIR (AB==BA)
{
mean_variance<-colourpairs
mean_variance$var<-NA
for (x in 1:nrow(mean_variance)) {  #makes a temporary dataframe with all the similarity ratings for one colourpair (x = row in mean_similarity ie. one per colourpair)
a<-subset(trialdata,trialdata$hex1==mean_variance$hex1[x] & trialdata$hex2==mean_variance$hex2[x], c(similarity)) #similarity with exact hex match
b<-subset(trialdata,trialdata$hex1==mean_variance$hex2[x] & trialdata$hex2==mean_variance$hex1[x], c(similarity)) #similarity with flipped hex order
c<-rbind(a, b) #all similarty ratings for colour pair x
mean_variance$var[x]<-var(c)
}
ggplot(mean_variance) +
aes(x = hex1, y = hex2, fill = var) +
geom_raster() +
scale_fill_gradient(name="Variance" ,low = "grey", high = "black", na.value = "green")+
ggthemes::theme_base()+
theme(axis.text.x= element_text(size= 6, angle=90, colour=sort(unique(mean_variance$hex1))))+
theme(axis.text.y = element_text(size= 6, colour=sort(unique(mean_variance$hex2))))+
theme(legend.position = "right")+
labs(x= "Colour presented first", y= "Colour presented second")
}
#MAKE DATAFRAME WITH ASYMMETRY INDEX (AsIn) for each participant
{
#Calculating absolute difference between first and second pass similatirity ratings
trialdata_passes$abs <- abs(trialdata_passes$firstpass_similarity-trialdata_passes$secondpass_similarity)
#Creating unique ID for each pair by combining participant ID and Colourpair
trialdata_passes$Colourpairperparticipant <- str_c(trialdata_passes$participant, '',trialdata_passes$Colourpair)
#selecting variables for asymmetry analysis
AsIndata_vars <- c("participant", "Colourpair", "Temporder", "hex1", "hex2", "similarity", "abs", "Colourpairperparticipant")
#making dataframe
AsIndata <- trialdata_passes[AsIndata_vars]
#changing to wide so that One row per colour pair per participant (4 ratings per row, first and second pass and reverse order)
AsIndata_wide <- reshape(AsIndata, idvar = "Colourpairperparticipant", timevar = "Temporder", direction = "wide")
#calculating Asymmetry Index as per Nao's formula (M13 -M24)/((A13+A24)+1)
AsIndata_wide$AsIn <- (AsIndata_wide$similarity.first - AsIndata_wide$similarity.second)/
((AsIndata_wide$abs.first + AsIndata_wide$abs.second) + 1)
#Create unique pair name by concatening first colour with second colour
AsIndata_wide$pair <- str_c(AsIndata_wide$hex1.first, '',AsIndata_wide$hex1.second)
#GET AsIn in Colourpairs DATAFRAME
get_mean_asymmetry <- function(z){
a<-subset(AsIndata_wide, pair==z) #similarity with exact hex match
mean<-mean(a$AsIn)
return(mean)
}
colourpairs$mean.asymmetry<-lapply(colourpairs$pair, get_mean_asymmetry)
colourpairs$mean.asymmetry<- as.numeric(colourpairs$mean.asymmetry)
test <- subset(colourpairs, is.na(colourpairs$mean.asymmetry))
test <- subset(AsIndata_wide, is.na(AsIndata_wide$AsIn))
}
mean_asymmetry<-mean_variance
mean_asymmetry$meanas<-NA
for (x in 1:nrow(mean_asymmetry)) {  #makes a temporary dataframe with all the similarity ratings for one colourpair (x = row in mean_similarity ie. one per colourpair)
a<-subset(AsIndata_wide,AsIndata_wide$hex1.first==mean_asymmetry$hex1[x] & AsIndata_wide$hex1.second==mean_asymmetry$hex2[x], c(AsIn)) #similarity with exact hex match
b<-subset(AsIndata_wide,AsIndata_wide$hex1.first==mean_asymmetry$hex2[x] & AsIndata_wide$hex1.second==mean_asymmetry$hex1[x], c(AsIn)) #similarity with flipped hex order
c<-rbind(a, b) #all similarty ratings for colour pair x
mean_asymmetry$meanas[x]<-mean(as.matrix(c))
}
#distribution of hitcounts
ggplot(colourpairs) +
aes(x= pair_hitcount) +
geom_bar() +
theme_minimal()
#
ggplot(mean_asymmetry)+
aes(x=meanas)+
geom_bar()+
theme_minimal()
#
ggplot(mean_asymmetry)+
aes(x=meanas)+
geom_density()+
theme_minimal()
# set lower triangle of matrix to NA - this gives heatmap its unique upper triangle
cor.matrix <- matrix(NA, ncol = 93, nrow = 93)
# setting all give colours as both row and column names
colnames(color.mat.df) <- rownames(color.mat.df) <- unique(trialdata$firstColourSetHEX)
# set lower triangle of matrix to NA - this gives heatmap its unique upper triangle
color.mat.df <- matrix(NA, ncol = 93, nrow = 93)
# setting all give colours as both row and column names
colnames(color.mat.df) <- rownames(color.mat.df) <- unique(trialdata$firstColourSetHEX)
head(color.mat.df)
View(colourpairs)
View(colourpairs)
gp.mean.data <- colourpairs[gp.mean.data_vars]
gp.mean.data_vars <- c("hex1", "hex2", "mean.similarity")
gp.mean.data <- colourpairs[gp.mean.data_vars]
View(gp.mean.data)
group.mean.mat.df <- matrix.df.fill(gp.mean.data,color.mat.df)
# fill matrix
matrix.df.fill <- function(data,matrix.df){
for(i in 1:nrow(data)){
#print(i)
row <- data[i,]
#print(matrix.df[row$firstColour,row$secondColour])
matrix.df[row$firstColour,row$secondColour] <- row$value
#matrix.df[row$secondColour,row$firstColour] <- row$value # symmetric
#print(matrix.df[row$firstColour,row$secondColour])
}
return(matrix.df)
}
group.mean.mat.df <- matrix.df.fill(gp.mean.data,color.mat.df)
head(group.mean.mat.df)
# Create blank matrix
color.mat.df <- matrix(NA, ncol = 93, nrow = 93)
# setting all give colours as both row and column names
colnames(color.mat.df) <- rownames(color.mat.df) <- unique(trialdata$firstColourSetHEX)
head(color.mat.df)
# setting all give colours as both row and column names
colnames(color.mat.df) <- rownames(color.mat.df) <- unique(trialdata$hex1)
head(color.mat.df)
group.mean.mat.df <- matrix.df.fill(gp.mean.data,color.mat.df)
head(group.mean.mat.df)
# fill matrix
matrix.df.fill <- function(data,matrix.df){
for(i in 1:nrow(data)){
#print(i)
row <- data[i,]
#print(matrix.df[row$firstColour,row$secondColour])
matrix.df[row$firstColour,row$secondColour] <- row$mean.similarity
#matrix.df[row$secondColour,row$firstColour] <- row$value # symmetric
#print(matrix.df[row$firstColour,row$secondColour])
}
return(matrix.df)
}
group.mean.mat.df <- matrix.df.fill(gp.mean.data,color.mat.df)
head(group.mean.mat.df)
# fill matrix
matrix.df.fill <- function(data,matrix.df){
for(i in 1:nrow(data)){
#print(i)
row <- data[i,]
#print(matrix.df[row$firstColour,row$secondColour])
matrix.df[row$hex1,row$hex2] <- row$mean.similarity
#matrix.df[row$secondColour,row$firstColour] <- row$value # symmetric
#print(matrix.df[row$firstColour,row$secondColour])
}
return(matrix.df)
}
group.mean.mat.df <- matrix.df.fill(gp.mean.data,color.mat.df)
head(group.mean.mat.df)
# for visualisation purposes, make a column value indicating correlation with first row
row.cor <- function(df){
v.cor <- vector()
for(i in 1:nrow(df)){
v.cor <- c(v.cor, cor(df[1],df[i]))
}
return(v.cor)
}
row.factors <- function(colors, correlations){
colors$cor <- correlations
ordered <- colors[order(-colors$cor),]
return(ordered$colour)
}
row.facs <- row.factors(unique(trialdata$hex1),row.cor(group.mean.mat.df))
View(colourpairs)
row.cor(group.mean.mat.df)
class(group.mean.mat.df)
group.mean.mat.df <- as.data.frame(group.mean.mat.df)
class(group.mean.mat.df)
head(group.mean.mat.df)
row.cor(group.mean.mat.df)
row.facs <- row.factors(unique(trialdata$hex1),row.cor(group.mean.mat.df))
row.facs <- row.factors(unique(colourpairs$hex1),row.cor(group.mean.mat.df))
row.facs <- row.factors(colourpairs,row.cor(group.mean.mat.df))
row.facs <- row.factors(colourpairs$hex1,row.cor(group.mean.mat.df))
row.facs
row.facs <- row.factors(as.data.frame(unique(colourpairs$hex1)),row.cor(group.mean.mat.df))
row.facs
test <- as.data.frame(unique(colourpairs$hex1))
head(test)
row.facs <- row.factors(test,row.cor(group.mean.mat.df))
View(test)
View(test)
test <- rename(test, colour = unique(colourpairs$hex1))
test <- rename(test, colour = 'unique(colourpairs$hex1)')
row.facs <- row.factors(test,row.cor(group.mean.mat.df))
colors_disordered <- as.data.frame(unique(colourpairs$hex1))
colors_disordered <- rename(test, colour = 'unique(colourpairs$hex1)')
row.facs <- row.factors(colors_disordered,row.cor(group.mean.mat.df))
View(mean_asymmetry)
mean_asymmetry$hex1 <- with(mean_asymmetry, factor(hex1, levels = row.facs))
mean_asymmetry$hex2 <- with(mean_asymmetry, factor(hex2, levels = row.facs))
#plot with mean_asymmetry  CORRECT ONE TO USE
ggplot(mean_asymmetry) +
aes(x = hex1, y = hex2, fill = meanas) +
geom_raster() +
scale_fill_distiller(palette = "RdBu", direction = 1, na.value = "green") +
ggthemes::theme_base()+
theme(axis.text.x= element_text(size= 7, angle=90, colour=row.facs))+
theme(axis.text.y = element_text(size= 7, colour=row.facs))
View(mean_asymmetry)
mean_asymmetry<-mean_variance
mean_asymmetry$meanas<-NA
for (x in 1:nrow(mean_asymmetry)) {  #makes a temporary dataframe with all the similarity ratings for one colourpair (x = row in mean_similarity ie. one per colourpair)
a<-subset(AsIndata_wide,AsIndata_wide$hex1.first==mean_asymmetry$hex1[x] & AsIndata_wide$hex1.second==mean_asymmetry$hex2[x], c(AsIn)) #similarity with exact hex match
b<-subset(AsIndata_wide,AsIndata_wide$hex1.first==mean_asymmetry$hex2[x] & AsIndata_wide$hex1.second==mean_asymmetry$hex1[x], c(AsIn)) #similarity with flipped hex order
c<-rbind(a, b) #all similarty ratings for colour pair x
mean_asymmetry$meanas[x]<-mean(as.matrix(c))
}
mean_asymmetry$hex1 <- factor(mean_asymmetry$hex1, levels = row.facs)
row.facs <- row.factors(colours_disordered,row.cor(group.mean.mat.df))
colours_disordered <- as.data.frame(unique(colourpairs$hex1))
colours_disordered <- rename(test, colour = 'unique(colourpairs$hex1)')
row.facs <- row.factors(colours_disordered,row.cor(group.mean.mat.df))
# Create blank matrix
color.mat.df <- matrix(NA, ncol = 93, nrow = 93)
# setting all give colours as both row and column names
colnames(color.mat.df) <- rownames(color.mat.df) <- unique(trialdata$hex1)
# fill matrix
matrix.df.fill <- function(data,matrix.df){
for(i in 1:nrow(data)){
#print(i)
row <- data[i,]
#print(matrix.df[row$firstColour,row$secondColour])
matrix.df[row$hex1,row$hex2] <- row$mean.similarity
#matrix.df[row$secondColour,row$firstColour] <- row$value # symmetric
#print(matrix.df[row$firstColour,row$secondColour])
}
return(matrix.df)
}
gp.mean.data_vars <- c("hex1", "hex2", "mean.similarity")
gp.mean.data <- colourpairs[gp.mean.data_vars]
group.mean.mat.df <- matrix.df.fill(gp.mean.data,color.mat.df)
group.mean.mat.df <- as.data.frame(group.mean.mat.df)
# for visualisation purposes, make a column value indicating correlation with first row
row.cor <- function(df){
v.cor <- vector()
for(i in 1:nrow(df)){
v.cor <- c(v.cor, cor(df[1],df[i]))
}
return(v.cor)
}
row.factors <- function(colors, correlations){
colors$cor <- correlations
ordered <- colors[order(-colors$cor),]
return(ordered$colour)
}
colours_disordered <- as.data.frame(unique(colourpairs$hex1))
colours_disordered <- rename(test, colour = 'unique(colourpairs$hex1)')
row.facs <- row.factors(colours_disordered,row.cor(group.mean.mat.df))
mean_asymmetry<-mean_variance
mean_asymmetry$meanas<-NA
for (x in 1:nrow(mean_asymmetry)) {  #makes a temporary dataframe with all the similarity ratings for one colourpair (x = row in mean_similarity ie. one per colourpair)
a<-subset(AsIndata_wide,AsIndata_wide$hex1.first==mean_asymmetry$hex1[x] & AsIndata_wide$hex1.second==mean_asymmetry$hex2[x], c(AsIn)) #similarity with exact hex match
b<-subset(AsIndata_wide,AsIndata_wide$hex1.first==mean_asymmetry$hex2[x] & AsIndata_wide$hex1.second==mean_asymmetry$hex1[x], c(AsIn)) #similarity with flipped hex order
c<-rbind(a, b) #all similarty ratings for colour pair x
mean_asymmetry$meanas[x]<-mean(as.matrix(c))
}
row.cor(group.mean.mat.df)
colours_disordered <- as.data.frame(unique(colourpairs$hex1))
colours_disordered <- rename(colours_disordered, colour = 'unique(colourpairs$hex1)')
row.facs <- row.factors(colours_disordered,row.cor(group.mean.mat.df))
mean_asymmetry$hex1 <- with(mean_asymmetry, factor(hex1, levels = row.facs))
mean_asymmetry$hex2 <- with(mean_asymmetry, factor(hex2, levels = row.facs))
#plot with mean_asymmetry  CORRECT ONE TO USE
ggplot(mean_asymmetry) +
aes(x = hex1, y = hex2, fill = meanas) +
geom_raster() +
scale_fill_distiller(palette = "RdBu", direction = 1, na.value = "green") +
ggthemes::theme_base()+
theme(axis.text.x= element_text(size= 7, angle=90, colour=row.facs))+
theme(axis.text.y = element_text(size= 7, colour=row.facs))
View(colourpairs)
test <-row.cor(group.mean.mat.df)
View(test)
test <-as.data.frame(row.cor(group.mean.mat.df))
View(test)
View(colors_disordered)
View(group.mean.mat.df)
View(test)
ggplot(colourpairs) +
aes(x = hex1, y = hex2, fill = mean.asymmetry) +
geom_raster() +
scale_fill_gradientn(colours = c("white","black"),
limits = c(0,7),
breaks=c(0,1,2,3,4,5,6,7),
na.value='green') +
ggthemes::theme_base()+
theme(axis.text.x= element_text(size= 7, angle=90, colour=sort(unique(colourpairs$hex1))))+
theme(axis.text.y = element_text(size= 7, colour=sort(unique(colourpairs$hex2))))
ggplot(mean_asymmetry) +
aes(x = hex1, y = hex2, fill = meanas) +
geom_raster() +
scale_fill_gradientn(colours = c("white","black"),
limits = c(0,7),
breaks=c(0,1,2,3,4,5,6,7),
na.value='green') +
ggthemes::theme_base()+
theme(axis.text.x= element_text(size= 7, angle=90, colour=row.facs))+
theme(axis.text.y = element_text(size= 7, colour=row.facs))
ggplot(mean_asymmetry) +
aes(x = hex1, y = hex2, fill = meanas) +
geom_raster() +
scale_fill_gradientn(colours = c("white","black"),
limits = c(0,7),
breaks=c(0,1,2,3,4,5,6,7)) +
ggthemes::theme_base()+
theme(axis.text.x= element_text(size= 7, angle=90, colour=row.facs))+
theme(axis.text.y = element_text(size= 7, colour=row.facs))
#plot with mean_asymmetry  CORRECT ONE TO USE
ggplot(mean_asymmetry) +
aes(x = hex1, y = hex2, fill = meanas) +
geom_raster() +
scale_fill_distiller(palette = "RdBu", direction = 1, na.value = "green") +
ggthemes::theme_base()+
theme(axis.text.x= element_text(size= 7, angle=90, colour=row.facs))+
theme(axis.text.y = element_text(size= 7, colour=row.facs))
#VISUALISE MEAN SIMILARITY
{ggplot(colourpairs) +
aes(x = hex1, y = hex2, fill = mean.similarity) +
geom_raster() +
scale_fill_gradientn(colors = rainbow(7),breaks= c(0,1,2,3,4,5,6,7))+
theme_pubr()+
theme(axis.text.x= element_text(size= 7, angle=90, colour=sort(unique(colourpairs$hex1))))+
theme(axis.text.y = element_text(size= 7, colour=sort(unique(colourpairs$hex2))))
}
View(colourpairs)
#APPLY COLOUR FACTORS TO COLOURPAIRS DATAFRAME
colourpairs$hex1 <- with(colourpairs, factor(hex1, levels = row.facs))
colourpairs$hex2 <- with(colourpairs, factor(hex2, levels = row.facs))
#VISUALISE MEAN SIMILARITY
{ggplot(colourpairs) +
aes(x = hex1, y = hex2, fill = mean.similarity) +
geom_raster() +
scale_fill_gradientn(colors = rainbow(7),breaks= c(0,1,2,3,4,5,6,7))+
theme_pubr()+
theme(axis.text.x= element_text(size= 7, angle=90, colour=row.facs))+
theme(axis.text.y = element_text(size= 7, colour=row.facs))
}
View(mean_asymmetry)
## T-TESTING UNCORRECTED
mean_asymmetry$p <- t.test(mean_asymmetry$meanas, mu = 0)
View(mean_asymmetry)
#plot with mean_asymmetry  CORRECT ONE TO USE
ggplot(mean_asymmetry) +
aes(x = hex1, y = hex2, fill = meanas) +
geom_raster() +
scale_fill_distiller(palette = "RdBu") +
ggthemes::theme_base()+
theme(axis.text.x= element_text(size= 7, angle=90, colour=row.facs))+
theme(axis.text.y = element_text(size= 7, colour=row.facs))
?scale_fill_distiller
#plot with mean_asymmetry  CORRECT ONE TO USE
ggplot(mean_asymmetry) +
aes(x = hex1, y = hex2, fill = meanas) +
geom_raster() +
scale_fill_distiller(palette = "RdBu", midpoint = 0,direction = 1, na.value = "green") +
ggthemes::theme_base()+
theme(axis.text.x= element_text(size= 7, angle=90, colour=row.facs))+
theme(axis.text.y = element_text(size= 7, colour=row.facs))
ggplot(mean_asymmetry) +
aes(x = hex1, y = hex2, fill = meanas) +
geom_raster() +
scale_fill_gradient2(low ="red", high= "blue", mid ="white", midpoint= 0, na.value = "green") +
ggthemes::theme_base()+
theme(axis.text.x= element_text(size= 7, angle=90, colour=row.facs))+
theme(axis.text.y = element_text(size= 7, colour=row.facs))
#plot with mean_asymmetry  CORRECT ONE TO USE
ggplot(mean_asymmetry) +
aes(x = hex1, y = hex2, fill = meanas) +
geom_raster() +
scale_fill_distiller(palette = "RdBu", direction = 1, na.value = "green") +
ggthemes::theme_base()+
theme(axis.text.x= element_text(size= 7, angle=90, colour=row.facs))+
theme(axis.text.y = element_text(size= 7, colour=row.facs))
