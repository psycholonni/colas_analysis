mean_variance$var<-NA
for (x in 1:nrow(mean_variance)) {  #makes a temporary dataframe with all the similarity ratings for one colourpair (x = row in mean_similarity ie. one per colourpair)
a<-subset(trialdata,trialdata$hex1==mean_variance$hex1[x] & trialdata$hex2==mean_variance$hex2[x], c(similarity)) #similarity with exact hex match
b<-subset(trialdata,trialdata$hex1==mean_variance$hex2[x] & trialdata$hex2==mean_variance$hex1[x], c(similarity)) #similarity with flipped hex order
c<-rbind(a, b) #all similarty ratings for colour pair x
mean_variance$var[x]<-var(c)
}
ggplot(mean_variance) +
aes(x = hex1, y = hex2, fill = var) +
geom_raster() +
scale_fill_gradient(name="Variance" ,low = "grey", high = "black", na.value = "green")+
theme_pubr()+
theme(axis.text.x= element_text(size= 6, angle=90, colour=row.facs))+
theme(axis.text.y = element_text(size= 6, colour=row.facs))+
theme(legend.position = "left")+
labs(x= "Colour presented first", y= "Colour presented second")
ggplot(mean_variance) +
aes(x = hex1, y = hex2, fill = var) +
geom_raster() +
scale_fill_gradient(name="Variance" ,low = "grey", high = "black", na.value = "green")+
theme_pubr()+
theme(axis.text.x= element_text(size= 6, angle=90, colour=row.facs))+
scale_x_discrete(labels=block_rep) + scale_y_discrete(labels=block_rep) +
theme(axis.text.y = element_text(size= 6, colour=row.facs))+
theme(legend.position = "left")+
labs(x= "Colour presented first", y= "Colour presented second")
View(mean_variance)
esquisse:::esquisser()
#Similarity variance x Times tested
ggplot(mean_variance) +
aes(x = pair_hitcount, y = var) +
geom_point(shape = "circle", position = "jitter") +
geom_smooth(span = 0.75) +
labs(x = "Times tested", y = "Variance in similarity") +
theme_minimal()
#Similarity variance x Times tested
ggplot(mean_variance) +
aes(x = pair_hitcount, y = var) +
geom_point(shape = "circle", position = "jitter") +
geom_smooth(span = 0.75) +
labs(x = "Times tested", y = "Variance in similarity") +
theme_pubr()
mean_variance$sd <- sqrt(mean_variance$var)
#Similarity variance x Times tested
ggplot(mean_variance) +
aes(x = pair_hitcount, y = sd) +
geom_point(shape = "circle", position = "jitter") +
geom_smooth(span = 0.75) +
labs(x = "Times tested", y = "Variance in similarity") +
theme_pubr()
#Similarity st.dev x Times tested
ggplot(mean_variance) +
aes(x = pair_hitcount, y = sd) +
geom_point(shape = "circle", position = "jitter") +
geom_smooth(span = 0.75) +
labs(x = "Times tested", y = "St dev in similarity") +
theme_pubr()
## ISHIHARA
library(readxl)
setwd("~/thesis/colas_analysis")
#make a list of data file names
files <- list.files(path="./data", pattern="*.csv", full.names=TRUE)
#make a dataframe binding all datafiles
data <- sapply(files, read.csv, simplify=FALSE) %>%
lapply(\(x) mutate(x, across(Ishi_textbox.text, as.character))) %>% bind_rows(.id = "fileId")
IH_vars<- c("participant", "Ishi_textbox.text", "imageaddress")
#make catch data frame
IHdata<-data[IH_vars]
#remove empty cells
IHdata <- IHdata %>% drop_na()
#Scoring reference
scoringtable<- read_excel("PictureConditions.xlsx")
#inserting correct answers to participants dataframe
IHdata <- merge(IHdata, scoringtable, by= "imageaddress")
#coercing answers into numeric for efficient matching
IHdata$answer.numeric <- as.numeric(IHdata$Ishi_textbox.text)
IHdata$match <- IHdata$answer.numeric==IHdata$correctanswer
#make dataframe with IH scores
IH_perperson<- data.frame(unique(IHdata$participant))
IH_perperson<-rename(IH_perperson, participant = unique.IHdata.participant.)
get_IHscoredecimal<- function(z){
temp_df <- subset(IHdata,participant==z)
total_IH <- nrow(temp_df)
correct_IH<- nrow(subset(temp_df,Ishi_textbox.text==correctanswer))
IHscoredecimal<-format(round(correct_IH/total_IH, 2), nsmall = 2)
IHscoredecimal<-as.numeric(IHscoredecimal)
return(IHscoredecimal)
}
#get IH correctly answered
{get_IHcorrectQs<- function(z){
temp_df <- subset(IHdata,participant==z)
correct_IH<- nrow(subset(temp_df,match==TRUE))
return(correct_IH)
}
IH_perperson$correctA<-lapply(IH_perperson$participant, get_IHcorrectQs)
IH_perperson$correctA <- as.numeric(IH_perperson$correctA)
}
#get IH questions answered
{get_IHtotal_answered<- function(z){
temp_df <- subset(IHdata,participant==z)
total_IH <- nrow(temp_df)
return(total_IH)
}
IH_perperson$total_answered<-lapply(IH_perperson$participant, get_IHtotal_answered)
IH_perperson$total_answered <- as.numeric(IH_perperson$total_answered)
}
IH_perperson$total_answered<-lapply(IH_perperson$participant, get_IHtotal_answered)
View(IH_perperson)
IH_perperson$total_answered <- as.numeric(IH_perperson$total_answered)
#this participant submitted two files
IH_perperson <- subset(IH_perperson,!participant == "61716a16c157db249e36fc46")
IH_perperson <- subset(IH_perperson,!participant == "614deecf67f2c8ccfe3df23b")
View(data)
#READ FILES
{
## Pilot data with Ishihara
#make a list of data file names
pilot.files <- list.files(path="./data/Pilot data", pattern="*.csv", full.names=TRUE)
#make a dataframe binding all datafiles
pilot.data <- sapply(pilot.files, read.csv, simplify=FALSE) %>% bind_rows(.id = "fileId")
#adding Ishihara colomn missing to allow rbind
pilot.data$Ishi_textbox.text <- NA
##Data with Ishihara test
#make a list of data file names
files <- list.files(path="./data", pattern="*.csv", full.names=TRUE)
#make a dataframe binding all datafiles
data <- sapply(files, read.csv, simplify=FALSE) %>%
lapply(\(x) mutate(x, across(Ishi_textbox.text, as.character))) %>% bind_rows(.id = "fileId")
##Data with Ishihara test
#make a list of data file names
waveiv.files <- list.files(path="./data/wave IV", pattern="*.csv", full.names=TRUE)
#make a dataframe binding all datafiles
waveiv.data <- sapply(waveiv.files, read.csv, simplify=FALSE) %>%
lapply(\(x) mutate(x, across(Ishi_textbox.text, as.character))) %>% bind_rows(.id = "fileId")
##Data with Ishihara test
#make a list of data file names
pb.files <- list.files(path="./data/Problematic file", pattern="*.csv", full.names=TRUE)
#make a dataframe binding all datafiles
pb.data <- sapply(pb.files, read.csv, simplify=FALSE) %>%
lapply(\(x) mutate(x, across(Ishi_textbox.text, as.character))) %>% bind_rows(.id = "fileId")
pb.data$textbox.text <- as.character(pb.data$textbox.text)
data <- bind_rows(pb.data, data, pilot.data, waveiv.data)
}
IH_vars<- c("participant", "Ishi_textbox.text", "imageaddress")
#make catch data frame
IHdata<-data[IH_vars]
#remove empty cells
IHdata <- IHdata %>% drop_na()
#Scoring reference
scoringtable<- read_excel("PictureConditions.xlsx")
#inserting correct answers to participants dataframe
IHdata <- merge(IHdata, scoringtable, by= "imageaddress")
#coercing answers into numeric for efficient matching
IHdata$answer.numeric <- as.numeric(IHdata$Ishi_textbox.text)
IHdata$match <- IHdata$answer.numeric==IHdata$correctanswer
#make dataframe with IH scores
IH_perperson<- data.frame(unique(IHdata$participant))
View(data)
IH_perperson<-rename(IH_perperson, participant = unique.IHdata.participant.)
#get IH correctly answered
{get_IHcorrectQs<- function(z){
temp_df <- subset(IHdata,participant==z)
correct_IH<- nrow(subset(temp_df,match==TRUE))
return(correct_IH)
}
IH_perperson$correctA<-lapply(IH_perperson$participant, get_IHcorrectQs)
IH_perperson$correctA <- as.numeric(IH_perperson$correctA)
}
#get IH questions answered
{get_IHtotal_answered<- function(z){
temp_df <- subset(IHdata,participant==z)
total_IH <- nrow(temp_df)
return(total_IH)
}
IH_perperson$total_answered<-lapply(IH_perperson$participant, get_IHtotal_answered)
IH_perperson$total_answered <- as.numeric(IH_perperson$total_answered)
}
View(IH_perperson)
#this participant submitted two files
IH_perperson <- subset(IH_perperson,!participant == "61716a16c157db249e36fc46")
IH_perperson <- subset(IH_perperson,!participant == "614deecf67f2c8ccfe3df23b")
#Distribution of IH scores
ggplot(IH_perperson, aes(correctA)) +
geom_histogram() +
scale_x_continuous(breaks = as.numeric(round(quantile(IH_perperson$correctA),digits = 2))) +
theme_pubr() +
theme(axis.line = element_blank())+
geom_rangeframe()+
labs(x="Ishihara score",
title= "Histogram of Ishihara score")
#below threshold of normal colour vision
IH_perperson.low <- subset(IH_perperson, correctA <14)
View(pass_correlation)
View(IH_perperson.low)
trialdata_passes <- subset(trialdata_passes, !participant %in% IH_perperson.low$participant)
#get unique hex arrangements
colourpairs <- unique(trialdata_passes[ , c("hex1", "hex2")])
#Create unique pair name by concatening first colour with second colour
colourpairs$pair <- str_c(colourpairs$hex1, '',colourpairs$hex2)
#do the same for trialdata_passes
trialdata_passes$pairofcolour <- str_c(trialdata_passes$hex1, '',trialdata_passes$hex2)
#adding count of colour pairs
get_pair_hitcount<-function(x){ #get number of hits on pair of colour (x = colourpair)
pair_hitcount<-sum(trialdata_passes$pairofcolour == x)
return(pair_hitcount)
}
colourpairs$pair_hitcount <-lapply(colourpairs$pair, get_pair_hitcount)
colourpairs$pair_hitcount <- as.integer(colourpairs$pair_hitcount)
#Counting times a colour pair was tested
get_pair_hitcount<-function(x){ #get number of hits on pair of colour (x = colourpair)
pair_hitcount<-sum(trialdata_passes$pairofcolour == x)
return(pair_hitcount)
}
colourpairs$pair_hitcount <-lapply(colourpairs$pair, get_pair_hitcount)
colourpairs$pair_hitcount <- as.integer(colourpairs$pair_hitcount)
#heatmap of hitcount (the more a pair is tested, the 'hotter' it gets)
ggplot(colourpairs) +
aes(x = hex1, y = hex2, fill= pair_hitcount) +
geom_raster() +
theme_pubr()+
theme(axis.text.x=element_text(angle=90,hjust=1, size=6, colour = sort(unique(colourpairs$hex1))),
axis.text.y = element_text(size = 6, colour = sort(unique(colourpairs$hex1))))+
theme(legend.position = "left")+
scale_fill_gradient(name= "Times tested",low = "grey", high = "black", na.value = "green")+
labs(x= "Colour presented first", y= "Colour presented second")
#distribution of hitcounts
ggplot(colourpairs) +
aes(x= pair_hitcount) +
geom_bar() +
theme_minimal()
#hitcount descriptives
summary(colourpairs$pair_hitcount)
sd(colourpairs$pair_hitcount)
get_mean_similarity <- function(z){
a<-subset(trialdata_passes, pairofcolour==z) #similarity with exact hex match
mean<-mean(a$similarity)
return(mean)
}
colourpairs$mean.similarity<-lapply(colourpairs$pair, get_mean_similarity)
colourpairs$mean.similarity<- as.numeric(colourpairs$mean.similarity)
#APPLY COLOUR FACTORS TO COLOURPAIRS DATAFRAME
colourpairs$hex1 <- with(colourpairs, factor(hex1, levels = row.facs))
colourpairs$hex2 <- with(colourpairs, factor(hex2, levels = row.facs))
#Calculating absolute difference between first and second pass similatirity ratings
trialdata_passes$abs <- abs(trialdata_passes$firstpass_similarity-trialdata_passes$secondpass_similarity)
#Creating unique ID for each pair by combining participant ID and Colourpair
trialdata_passes$Colourpairperparticipant <- str_c(trialdata_passes$participant, '',trialdata_passes$Colourpair)
#selecting variables for asymmetry analysis
AsIndata_vars <- c("participant", "Colourpair", "Temporder", "hex1", "hex2", "similarity", "abs", "Colourpairperparticipant")
#making dataframe
AsIndata <- trialdata_passes[AsIndata_vars]
#changing to wide so that One row per colour pair per participant (4 ratings per row, first and second pass and reverse order)
AsIndata_wide <- reshape(AsIndata, idvar = "Colourpairperparticipant", timevar = "Temporder", direction = "wide")
#renaming because temporder first second makes it confusing with first/second pass
names(AsIndata_wide)[names(AsIndata_wide) == "similarity.first"] <- "mean13" #similarity.first was the mean of the pair for the first temporder so mean13
names(AsIndata_wide)[names(AsIndata_wide) == "similarity.second"] <- "mean24"
#Create unique pair name by concatening first colour with second colour
AsIndata_wide$pair13 <- str_c(AsIndata_wide$hex1.first, '',AsIndata_wide$hex2.first)
AsIndata_wide$pair24 <- str_c(AsIndata_wide$hex1.second, '',AsIndata_wide$hex2.second)
#calculating Asymmetry Index as per Nao's formula (M13 -M24)/((A13+A24)+1)
AsIndata_wide$AsIn13 <- (AsIndata_wide$mean13 - AsIndata_wide$mean24)/
((AsIndata_wide$abs.first + AsIndata_wide$abs.second) + 1)
#calculating Asymmetry Index as per Nao's formula (M24 -M13)/((A13+A24)+1)
AsIndata_wide$AsIn24 <- (AsIndata_wide$mean24 - AsIndata_wide$mean13)/
((AsIndata_wide$abs.first + AsIndata_wide$abs.second) + 1)
get_mean_asymmetry <- function(z){
a<-subset(AsIndata_wide, pair13==z) #getting all the instance in pair13 matching the pair of hexcodes
a<- a["AsIn13"] #only keeping the asymmetry score of interest
names(a)[names(a)== "AsIn13"] <- "AsIn" #rename to be able to rbind with b
b<-subset(AsIndata_wide, pair24==z) #repeating with pair24
b<- b["AsIn24"] # again keeping only AsIn24
names(b)[names(b)== "AsIn24"] <- "AsIn" #rename to be able to rbind with a
c <-rbind(a, b)
AsIn <- mean(c$AsIn)
return(AsIn)
}
colourpairs$mean.asymmetry<-lapply(colourpairs$pair, get_mean_asymmetry) #apply function
View(participants_ubercomplete)
colourpairs$mean.asymmetry<- as.numeric(colourpairs$mean.asymmetry) #make it numeric
#GET AsIn variance
get_var_asymmetry <- function(z) {  #makes a temporary dataframe with all the similarity ratings for one colourpair (x = row in mean_similarity ie. one per colourpair)
a<-subset(AsIndata_wide, pair13==z) #getting all the instance in pair13 matching the pair of hexcodes
a<- a["AsIn13"] #only keeping the asymmetry score of interest
names(a)[names(a)== "AsIn13"] <- "AsIn" #rename to be able to rbind with b
b<-subset(AsIndata_wide, pair24==z) #repeating with pair24
b<- b["AsIn24"] # again keeping only AsIn24
names(b)[names(b)== "AsIn24"] <- "AsIn" #rename to be able to rbind with a
c <-rbind(a, b) #combine both subset to have complete
var.AsIn <- var(c$AsIn)
return(var.AsIn)
}
colourpairs$var.asymmetry<-lapply(colourpairs$pair, get_var_asymmetry) #apply function
colourpairs$var.asymmetry<- as.numeric(colourpairs$var.asymmetry) #make it numeric
colourpairs$sem.asymmetry <- sqrt(colourpairs$var.asymmetry)/sqrt(colourpairs$pair_hitcount)
#plot with colour pairs CORRECT ONE TO USE
ggplot(colourpairs) +
aes(x = hex1, y = hex2, fill = mean.asymmetry) +
geom_raster() +
scale_fill_gradient2(low ="red", high= "blue", mid ="white", midpoint= 0, na.value = "green") +
scale_x_discrete(labels=block_rep) + scale_y_discrete(labels=block_rep) +
theme_pubr()+
theme(legend.position = "left")+
theme(axis.text.x= element_text(size= 5, angle=90, colour=row.facs))+
theme(axis.text.y = element_text(size= 5, colour=row.facs))
# density plot of mean asymmetry
ggplot(colourpairs)+
aes(x=mean.asymmetry)+
geom_density()+
theme_pubr()+
geom_vline(xintercept = 0, colour ="grey")
## T-TESTING UNCORRECTED --- WIP
colourpairs$t <- NA
colourpairs$t <- colourpairs$mean.asymmetry/(sqrt(colourpairs$var.asymmetry)/sqrt(colourpairs$pair_hitcount))
#t-score matrix
ggplot(colourpairs)+
aes(x = hex1, y = hex2, fill = t) +
geom_raster() +
scale_fill_gradient2(low ="red", high= "blue", mid ="white", midpoint= 0, na.value = "green") +
scale_x_discrete(labels=block_rep) + scale_y_discrete(labels=block_rep) +
theme_pubr()+
theme(legend.position = "left")+
theme(axis.text.x= element_text(size= 5, angle=90, colour=row.facs))+
theme(axis.text.y = element_text(size= 5, colour=row.facs))
#t-score x Variance zoomed in
ggplot(colourpairs) +
aes(y = t, x = var.asymmetry) +
geom_point() +
geom_hline(yintercept = 0, colour = "red")+
geom_hline(yintercept = 2, colour = "blue")+
geom_hline(yintercept = 4, colour = "green")+
theme_pubr()+
ylim(0,6)+
xlim(0,1)
#t-score x Times tested
ggplot(colourpairs) +
aes(y = t, x = pair_hitcount) +
geom_point() +
theme_pubr()+
ylim(0,15)
#Boxplot of t-values per times tested
ggplot(colourpairs) +
aes(y = t)+
geom_boxplot(aes(group = factor(pair_hitcount)))+
theme_pubr()+
coord_cartesian(ylim= c(0,15))
## p-TESTING UNCORRECTED --- WIP
colourpairs$p <- NA
colourpairs$p <- 2*pt(abs(colourpairs$t), df= colourpairs$pair_hitcount-1, lower.tail = FALSE)
colourpairs$p <- round(colourpairs$p, 4)
candidates_p <- subset(colourpairs, p<.05)
#p vs times tested zoomed in low p values
ggplot(colourpairs) +
aes(y = p, x = pair_hitcount) +
geom_point() +
theme_pubr()+
ylim(0,.1)
#p-testing CORRECTED --- WIP
colourpairs$p.adjust <- NA
colourpairs$p.adjust <- p.adjust(colourpairs$p, method = "holm", n= length(colourpairs$p))
#MAKE DATAFRAME WITH ASYMMETRY INDEX (AsIn) for each participant
{
#Calculating absolute difference between first and second pass similatirity ratings
trialdata_passes$abs <- abs(trialdata_passes$firstpass_similarity-trialdata_passes$secondpass_similarity)
#Creating unique ID for each pair by combining participant ID and Colourpair
trialdata_passes$Colourpairperparticipant <- str_c(trialdata_passes$participant, '',trialdata_passes$Colourpair)
#selecting variables for asymmetry analysis
AsIndata_vars <- c("participant", "Colourpair", "Temporder", "hex1", "hex2", "similarity", "abs", "Colourpairperparticipant")
#making dataframe
AsIndata <- trialdata_passes[AsIndata_vars]
#changing to wide so that One row per colour pair per participant (4 ratings per row, first and second pass and reverse order)
AsIndata_wide <- reshape(AsIndata, idvar = "Colourpairperparticipant", timevar = "Temporder", direction = "wide")
#renaming because temporder first second makes it confusing with first/second pass
names(AsIndata_wide)[names(AsIndata_wide) == "similarity.first"] <- "mean13" #similarity.first was the mean of the pair for the first temporder so mean13
names(AsIndata_wide)[names(AsIndata_wide) == "similarity.second"] <- "mean24"
#Create unique pair name by concatening first colour with second colour
AsIndata_wide$pair13 <- str_c(AsIndata_wide$hex1.first, '',AsIndata_wide$hex2.first)
AsIndata_wide$pair24 <- str_c(AsIndata_wide$hex1.second, '',AsIndata_wide$hex2.second)
#calculating Asymmetry Index as per Nao's formula (M13 -M24)/((A13+A24)+1)
AsIndata_wide$AsIn13 <- (AsIndata_wide$mean13 - AsIndata_wide$mean24)
#calculating Asymmetry Index as per Nao's formula (M24 -M13)/((A13+A24)+1)
AsIndata_wide$AsIn24 <- (AsIndata_wide$mean24 - AsIndata_wide$mean13)
}
#GET AsIn in Colourpairs DATAFRAME
{
get_mean_asymmetry <- function(z){
a<-subset(AsIndata_wide, pair13==z) #getting all the instance in pair13 matching the pair of hexcodes
a<- a["AsIn13"] #only keeping the asymmetry score of interest
names(a)[names(a)== "AsIn13"] <- "AsIn" #rename to be able to rbind with b
b<-subset(AsIndata_wide, pair24==z) #repeating with pair24
b<- b["AsIn24"] # again keeping only AsIn24
names(b)[names(b)== "AsIn24"] <- "AsIn" #rename to be able to rbind with a
c <-rbind(a, b)
AsIn <- mean(c$AsIn)
return(AsIn)
}
colourpairs$mean.asymmetry<-lapply(colourpairs$pair, get_mean_asymmetry) #apply function
colourpairs$mean.asymmetry<- as.numeric(colourpairs$mean.asymmetry) #make it numeric
}
#GET AsIn variance
get_var_asymmetry <- function(z) {  #makes a temporary dataframe with all the similarity ratings for one colourpair (x = row in mean_similarity ie. one per colourpair)
a<-subset(AsIndata_wide, pair13==z) #getting all the instance in pair13 matching the pair of hexcodes
a<- a["AsIn13"] #only keeping the asymmetry score of interest
names(a)[names(a)== "AsIn13"] <- "AsIn" #rename to be able to rbind with b
b<-subset(AsIndata_wide, pair24==z) #repeating with pair24
b<- b["AsIn24"] # again keeping only AsIn24
names(b)[names(b)== "AsIn24"] <- "AsIn" #rename to be able to rbind with a
c <-rbind(a, b) #combine both subset to have complete
var.AsIn <- var(c$AsIn)
return(var.AsIn)
}
#B&W
ggplot(colourpairs) +
aes(x = hex1, y = hex2, fill = mean.similarity) +
geom_raster() +
scale_fill_gradient(low= "grey", high= "black",breaks= c(0,1,2,3,4,5,6,7))+
theme_pubr()+
theme(legend.position = "left")+
theme(axis.text.x= element_text(size= 5, angle=90, colour=row.facs))+
theme(axis.text.y = element_text(size= 5, colour=row.facs))+
scale_x_discrete(labels=block_rep) + scale_y_discrete(labels=block_rep) +
labs(x= "Colour presented first", y= "Colour presented second")
mean_variance<-colourpairs
mean_variance$var<-NA
for (x in 1:nrow(mean_variance)) {  #makes a temporary dataframe with all the similarity ratings for one colourpair (x = row in mean_similarity ie. one per colourpair)
a<-subset(trialdata,trialdata$hex1==mean_variance$hex1[x] & trialdata$hex2==mean_variance$hex2[x], c(similarity)) #similarity with exact hex match
b<-subset(trialdata,trialdata$hex1==mean_variance$hex2[x] & trialdata$hex2==mean_variance$hex1[x], c(similarity)) #similarity with flipped hex order
c<-rbind(a, b) #all similarty ratings for colour pair x
mean_variance$var[x]<-var(c)
}
ggplot(mean_variance) +
aes(x = hex1, y = hex2, fill = var) +
geom_raster() +
scale_fill_gradient(name="Variance" ,low = "grey", high = "black", na.value = "green")+
theme_pubr()+
theme(axis.text.x= element_text(size= 6, angle=90, colour=row.facs))+
scale_x_discrete(labels=block_rep) + scale_y_discrete(labels=block_rep) +
theme(axis.text.y = element_text(size= 6, colour=row.facs))+
theme(legend.position = "left")+
labs(x= "Colour presented first", y= "Colour presented second")
#Standard deviation of similarity ratings per colour pair
mean_variance$sd <- sqrt(mean_variance$var)
#Similarity st.dev x Times tested
ggplot(mean_variance) +
aes(x = pair_hitcount, y = sd) +
geom_point(shape = "circle", position = "jitter") +
geom_smooth(span = 0.75) +
labs(x = "Times tested", y = "St dev in similarity") +
theme_pubr()
colourpairs$var.asymmetry<-lapply(colourpairs$pair, get_var_asymmetry) #apply function
colourpairs$var.asymmetry<- as.numeric(colourpairs$var.asymmetry) #make it numeric
colourpairs$sem.asymmetry <- sqrt(colourpairs$var.asymmetry)/sqrt(colourpairs$pair_hitcount)
#plot with colour pairs CORRECT ONE TO USE
ggplot(colourpairs) +
aes(x = hex1, y = hex2, fill = mean.asymmetry) +
geom_raster() +
scale_fill_viridis_c(option = "viridis", direction = 1) +
scale_x_discrete(labels=block_rep) + scale_y_discrete(labels=block_rep) +
theme_pubr()+
theme(legend.position = "left")+
theme(axis.text.x= element_text(size= 5, angle=90, colour=row.facs))+
theme(axis.text.y = element_text(size= 5, colour=row.facs))
#plot with colour pairs CORRECT ONE TO USE
ggplot(colourpairs) +
aes(x = hex1, y = hex2, fill = mean.asymmetry) +
geom_raster() +
scale_fill_gradient2(low ="red", high= "blue", mid ="white", midpoint= 0, na.value = "green") + scale_x_discrete(labels=block_rep) + scale_y_discrete(labels=block_rep) +
theme_pubr()+
theme(legend.position = "left")+
theme(axis.text.x= element_text(size= 5, angle=90, colour=row.facs))+
theme(axis.text.y = element_text(size= 5, colour=row.facs))
# density plot of mean asymmetry
ggplot(colourpairs)+
aes(x=mean.asymmetry)+
geom_density()+
theme_pubr()+
geom_vline(xintercept = 0, colour ="grey")
ks.test(colourpairs$mean.asymmetry, "pnorm", 0, sd(colourpairs$mean.asymmetry))
View(candidates_p)
IH_vars<- c("participant", "Ishi_textbox.text", "imageaddress")
#make catch data frame
IHdata<-data[IH_vars]
#remove empty cells
IHdata <- IHdata %>% drop_na()
#Scoring reference
scoringtable<- read_excel("PictureConditions.xlsx")
#inserting correct answers to participants dataframe
IHdata <- merge(IHdata, scoringtable, by= "imageaddress")
#coercing answers into numeric for efficient matching
IHdata$answer.numeric <- as.numeric(IHdata$Ishi_textbox.text)
IHdata$match <- IHdata$answer.numeric==IHdata$correctanswer
#make dataframe with IH scores
IH_perperson<- data.frame(unique(IHdata$participant))
IH_perperson<-rename(IH_perperson, participant = unique.IHdata.participant.)
#get IH correctly answered
{get_IHcorrectQs<- function(z){
temp_df <- subset(IHdata,participant==z)
correct_IH<- nrow(subset(temp_df,match==TRUE))
return(correct_IH)
}
IH_perperson$correctA<-lapply(IH_perperson$participant, get_IHcorrectQs)
IH_perperson$correctA <- as.numeric(IH_perperson$correctA)
}
#get IH questions answered
{get_IHtotal_answered<- function(z){
temp_df <- subset(IHdata,participant==z)
total_IH <- nrow(temp_df)
return(total_IH)
}
IH_perperson$total_answered<-lapply(IH_perperson$participant, get_IHtotal_answered)
IH_perperson$total_answered <- as.numeric(IH_perperson$total_answered)
}
View(IH_perperson)
