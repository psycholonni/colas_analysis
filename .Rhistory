#calculating Asymmetry Index as per Nao's formula (M13 -M24)/((A13+A24)+1)
AsIndata_wide$AsIn13 <- (AsIndata_wide$mean13 - AsIndata_wide$mean24)
#calculating Asymmetry Index as per Nao's formula (M24 -M13)/((A13+A24)+1)
AsIndata_wide$AsIn24 <- (AsIndata_wide$mean24 - AsIndata_wide$mean13)
}
#GET AsIn in Colourpairs DATAFRAME
{
get_mean_asymmetry <- function(z){
a<-subset(AsIndata_wide, pair13==z) #getting all the instance in pair13 matching the pair of hexcodes
a<- a["AsIn13"] #only keeping the asymmetry score of interest
names(a)[names(a)== "AsIn13"] <- "AsIn" #rename to be able to rbind with b
b<-subset(AsIndata_wide, pair24==z) #repeating with pair24
b<- b["AsIn24"] # again keeping only AsIn24
names(b)[names(b)== "AsIn24"] <- "AsIn" #rename to be able to rbind with a
c <-rbind(a, b)
AsIn <- mean(c$AsIn)
return(AsIn)
}
colourpairs$mean.asymmetry<-lapply(colourpairs$pair, get_mean_asymmetry) #apply function
colourpairs$mean.asymmetry<- as.numeric(colourpairs$mean.asymmetry) #make it numeric
}
#GET AsIn variance
get_var_asymmetry <- function(z) {  #makes a temporary dataframe with all the similarity ratings for one colourpair (x = row in mean_similarity ie. one per colourpair)
a<-subset(AsIndata_wide, pair13==z) #getting all the instance in pair13 matching the pair of hexcodes
a<- a["AsIn13"] #only keeping the asymmetry score of interest
names(a)[names(a)== "AsIn13"] <- "AsIn" #rename to be able to rbind with b
b<-subset(AsIndata_wide, pair24==z) #repeating with pair24
b<- b["AsIn24"] # again keeping only AsIn24
names(b)[names(b)== "AsIn24"] <- "AsIn" #rename to be able to rbind with a
c <-rbind(a, b) #combine both subset to have complete
var.AsIn <- var(c$AsIn)
return(var.AsIn)
}
#B&W
ggplot(colourpairs) +
aes(x = hex1, y = hex2, fill = mean.similarity) +
geom_raster() +
scale_fill_gradient(low= "grey", high= "black",breaks= c(0,1,2,3,4,5,6,7))+
theme_pubr()+
theme(legend.position = "left")+
theme(axis.text.x= element_text(size= 5, angle=90, colour=row.facs))+
theme(axis.text.y = element_text(size= 5, colour=row.facs))+
scale_x_discrete(labels=block_rep) + scale_y_discrete(labels=block_rep) +
labs(x= "Colour presented first", y= "Colour presented second")
mean_variance<-colourpairs
mean_variance$var<-NA
for (x in 1:nrow(mean_variance)) {  #makes a temporary dataframe with all the similarity ratings for one colourpair (x = row in mean_similarity ie. one per colourpair)
a<-subset(trialdata,trialdata$hex1==mean_variance$hex1[x] & trialdata$hex2==mean_variance$hex2[x], c(similarity)) #similarity with exact hex match
b<-subset(trialdata,trialdata$hex1==mean_variance$hex2[x] & trialdata$hex2==mean_variance$hex1[x], c(similarity)) #similarity with flipped hex order
c<-rbind(a, b) #all similarty ratings for colour pair x
mean_variance$var[x]<-var(c)
}
ggplot(mean_variance) +
aes(x = hex1, y = hex2, fill = var) +
geom_raster() +
scale_fill_gradient(name="Variance" ,low = "grey", high = "black", na.value = "green")+
theme_pubr()+
theme(axis.text.x= element_text(size= 6, angle=90, colour=row.facs))+
scale_x_discrete(labels=block_rep) + scale_y_discrete(labels=block_rep) +
theme(axis.text.y = element_text(size= 6, colour=row.facs))+
theme(legend.position = "left")+
labs(x= "Colour presented first", y= "Colour presented second")
#Standard deviation of similarity ratings per colour pair
mean_variance$sd <- sqrt(mean_variance$var)
#Similarity st.dev x Times tested
ggplot(mean_variance) +
aes(x = pair_hitcount, y = sd) +
geom_point(shape = "circle", position = "jitter") +
geom_smooth(span = 0.75) +
labs(x = "Times tested", y = "St dev in similarity") +
theme_pubr()
colourpairs$var.asymmetry<-lapply(colourpairs$pair, get_var_asymmetry) #apply function
colourpairs$var.asymmetry<- as.numeric(colourpairs$var.asymmetry) #make it numeric
colourpairs$sem.asymmetry <- sqrt(colourpairs$var.asymmetry)/sqrt(colourpairs$pair_hitcount)
#plot with colour pairs CORRECT ONE TO USE
ggplot(colourpairs) +
aes(x = hex1, y = hex2, fill = mean.asymmetry) +
geom_raster() +
scale_fill_viridis_c(option = "viridis", direction = 1) +
scale_x_discrete(labels=block_rep) + scale_y_discrete(labels=block_rep) +
theme_pubr()+
theme(legend.position = "left")+
theme(axis.text.x= element_text(size= 5, angle=90, colour=row.facs))+
theme(axis.text.y = element_text(size= 5, colour=row.facs))
#plot with colour pairs CORRECT ONE TO USE
ggplot(colourpairs) +
aes(x = hex1, y = hex2, fill = mean.asymmetry) +
geom_raster() +
scale_fill_gradient2(low ="red", high= "blue", mid ="white", midpoint= 0, na.value = "green") + scale_x_discrete(labels=block_rep) + scale_y_discrete(labels=block_rep) +
theme_pubr()+
theme(legend.position = "left")+
theme(axis.text.x= element_text(size= 5, angle=90, colour=row.facs))+
theme(axis.text.y = element_text(size= 5, colour=row.facs))
# density plot of mean asymmetry
ggplot(colourpairs)+
aes(x=mean.asymmetry)+
geom_density()+
theme_pubr()+
geom_vline(xintercept = 0, colour ="grey")
ks.test(colourpairs$mean.asymmetry, "pnorm", 0, sd(colourpairs$mean.asymmetry))
View(candidates_p)
IH_vars<- c("participant", "Ishi_textbox.text", "imageaddress")
#make catch data frame
IHdata<-data[IH_vars]
#remove empty cells
IHdata <- IHdata %>% drop_na()
#Scoring reference
scoringtable<- read_excel("PictureConditions.xlsx")
#inserting correct answers to participants dataframe
IHdata <- merge(IHdata, scoringtable, by= "imageaddress")
#coercing answers into numeric for efficient matching
IHdata$answer.numeric <- as.numeric(IHdata$Ishi_textbox.text)
IHdata$match <- IHdata$answer.numeric==IHdata$correctanswer
#make dataframe with IH scores
IH_perperson<- data.frame(unique(IHdata$participant))
IH_perperson<-rename(IH_perperson, participant = unique.IHdata.participant.)
#get IH correctly answered
{get_IHcorrectQs<- function(z){
temp_df <- subset(IHdata,participant==z)
correct_IH<- nrow(subset(temp_df,match==TRUE))
return(correct_IH)
}
IH_perperson$correctA<-lapply(IH_perperson$participant, get_IHcorrectQs)
IH_perperson$correctA <- as.numeric(IH_perperson$correctA)
}
#get IH questions answered
{get_IHtotal_answered<- function(z){
temp_df <- subset(IHdata,participant==z)
total_IH <- nrow(temp_df)
return(total_IH)
}
IH_perperson$total_answered<-lapply(IH_perperson$participant, get_IHtotal_answered)
IH_perperson$total_answered <- as.numeric(IH_perperson$total_answered)
}
View(IH_perperson)
#block most warnings when loading libraries
shhh <- suppressPackageStartupMessages
{library(tidyr)
library(plyr)
library(dplyr) %>% shhh
library(ggplot2)
library(gridExtra) %>% shhh
library(MASS) %>% shhh
library(Matrix) %>% shhh
library(reshape2)%>% shhh
library(ape) %>% shhh # stats
library(vegan) %>% shhh # stats
library(RColorBrewer)
library(cocor)
library(DescTools) %>% shhh
library(reshape2)
library(grid)
library(ggplotify)
library(ggpubr) %>% shhh
library(ggthemes)
library(stringr)
library(rgl)
library(tidyverse)
library(plot.matrix) %>% shhh
library(farver)
library(matrixStats) %>% shhh
library(plotrix) %>% shhh
library(JWileymisc)
library(readxl)}
setwd("~/thesis/colas_analysis")
#READ FILES
{
## Pilot data with Ishihara
#make a list of data file names
pilot.files <- list.files(path="./data/Pilot data", pattern="*.csv", full.names=TRUE)
#make a dataframe binding all datafiles
pilot.data <- sapply(pilot.files, read.csv, simplify=FALSE) %>% bind_rows(.id = "fileId")
#adding Ishihara colomn missing to allow rbind
pilot.data$Ishi_textbox.text <- NA
##Data with Ishihara test
#make a list of data file names
files <- list.files(path="./data", pattern="*.csv", full.names=TRUE)
#make a dataframe binding all datafiles
data <- sapply(files, read.csv, simplify=FALSE) %>%
lapply(\(x) mutate(x, across(Ishi_textbox.text, as.character))) %>% bind_rows(.id = "fileId")
##Data with Ishihara test
#make a list of data file names
waveiv.files <- list.files(path="./data/wave IV", pattern="*.csv", full.names=TRUE)
#make a dataframe binding all datafiles
waveiv.data <- sapply(waveiv.files, read.csv, simplify=FALSE) %>%
lapply(\(x) mutate(x, across(Ishi_textbox.text, as.character))) %>% bind_rows(.id = "fileId")
##Data with Ishihara test
#make a list of data file names
pb.files <- list.files(path="./data/Problematic file", pattern="*.csv", full.names=TRUE)
#make a dataframe binding all datafiles
pb.data <- sapply(pb.files, read.csv, simplify=FALSE) %>%
lapply(\(x) mutate(x, across(Ishi_textbox.text, as.character))) %>% bind_rows(.id = "fileId")
pb.data$textbox.text <- as.character(pb.data$textbox.text)
data <- bind_rows(pb.data, data, pilot.data, waveiv.data)
}
View(data)
# select variable of interest
framerate_vars<- c("participant", "frameRate")
#make  data frame
framedata<-data[, framerate_vars]
#remove empty cells
framedata <- framedata %>% drop_na()
mean(framedata$frameRate)
ggplot(framedata)+
geom_density(frameRate)
ggplot(framedata)+
geom_density(x= frameRate)
ggplot(framedata)+
geom_density(framedata$frameRate)
ggplot(framedata)+
geom_density(aes(frameRate))
low_FR <- data[frameRate<63.53731]
low_FR <- data[frameRate<63.53731,]
low_FR <- data[data$frameRate<63.53731,]
View(low_FR)
median(framedata$frameRate)
low_FR <- data[data$frameRate<59,]
unique(low_FR$participant)
shit_FR <- unique(low_FR$participant)
shitty_FR <- unique(low_FR$participant)
#ariel's cheat to display
block <- paste(strrep("\U2588",10),sep='')
block_rep <- rep(block,93)
#Create list of colours for factors
{file <- read_xlsx("colourcodes.xlsx")
##CONVERT RGB TO HEX
#split rgb strings
#x=rgb string
splitrgb <-function(x){
variable<-str_replace_all(x, "\\[|\\]", "") #delete brackets
variable<-strsplit(variable, split = ",") #split string
variable<-lapply(variable, as.numeric)   #convert to numeric
variable<-lapply(variable, "/", 100)  #convert rgb scale
variable<-lapply(variable, "*", 255)
return (as.list(unlist(variable)))
}
#remove last character to clean
file$Colourcodes2 <- str_remove(file$Colourcodes, ";")
file$colour <- lapply(file$Colourcodes2, splitrgb)
#make dataframes with rows per r, g, and b
colour_df <- as.data.frame(lapply(file$colour, function(x) t(do.call(cbind, x))))
#swap rows and columns
colour_df <- t(colour_df)
#name columns
colnames(colour_df) <- c("r", "g", "b")
#turn into a dataframe
colour_df<-as.data.frame(colour_df)
colour_df$hex <- NA
#rgb2hex function
rgb2hex <- function(r, g, b) {rgb(r, g, b, maxColorValue = 255)}
#Get hexcode
colour_df$hex <- apply(colour_df, 1, function(x) rgb2hex(x[1], x[2], x[3]))
row.facs <- colour_df$hex
}
low_FR <- data[data$frameRate<50,]
shitty_FR <- unique(low_FR$participant)
ggplot(low_FR)+
geom_density(aes(frameRate))
data <- data[data$frameRate>48]
data <- data[data$frameRate>48,]
#select catch variables for analysis
catch_vars<- c("participant", "catchnumber", "catchresponse", "response_time_catch")
#make catch data frame
catchdata<-data[data$Catch==1, catch_vars]
#remove empty cells
catchdata <- catchdata %>% drop_na()
#format response time
catchdata$response_time_catch<-as.numeric(catchdata$response_time_catch) #for graphing later
#MAKE CATCH_PERPERSON DATAFRAME WITH ONE ROW PER PARTICIPANT
{
#make dataframe with catch scores and mean response times
catch_perperson<- data.frame(unique(catchdata$participant))
catch_perperson<-rename(catch_perperson, participant = unique.catchdata.participant.)
#get catch score as decimal
#z=participant id
get_catchscoredecimal<- function(z){
temp_df <- subset(catchdata,participant==z)
total_catch <- nrow(temp_df)
correct_catch<- nrow(subset(temp_df,catchnumber==catchresponse))
catchscoredecimal<-format(round(correct_catch/total_catch, 2), nsmall = 2)
catchscoredecimal<-as.numeric(catchscoredecimal)
return(catchscoredecimal)
}
catch_perperson$score_decimal<-lapply(catch_perperson$participant, get_catchscoredecimal)
#get catch score as fraction - NOT VERY USEFUL
#z=participant id
get_catchscorefraction<- function(z){
temp_df <- subset(catchdata,participant==z)
total_catch <- nrow(temp_df)
correct_catch<- nrow(subset(temp_df,catchnumber==catchresponse))
catchscorefraction<-paste(correct_catch,"/",total_catch)
return(catchscorefraction)
}
catch_perperson$score_fraction<-lapply(catch_perperson$participant, get_catchscorefraction)
#get mean catch response times
#z=participant id
get_catchresponsetime<- function(z){
temp_df <- subset(catchdata,participant==z)
catchresponsetime<-mean(temp_df$response_time_catch)
return(catchresponsetime)
}
catch_perperson$response_time<-lapply(catch_perperson$participant, get_catchresponsetime)
}
#MAKING TRIALDATA DATAFRAME WITH ONE ROW PER TRIAL, FOR ALL PARTICIPANTS
{
#select trial variables for analysis
trial_vars<- c("participant", "Circle1_colour", "Circle2_colour", "Colourpair", "similarity", "response_time", "Temporder")
#make trial data frame
trialdata <- data[trial_vars]
#remove empty cells
trialdata <- trialdata %>% drop_na()
trialdata<- trialdata[!apply(trialdata == "", 1, any),]
#remove participants with low catch scores (<0.8)
high_catch<-subset(catch_perperson, score_decimal>=0.8)
low_catch <-subset(catch_perperson, score_decimal<0.8)
trialdata<-subset(trialdata, participant %in% high_catch$participant)
#remove participants with incomplete data
participants <- data.frame(unique(trialdata$participant)) #make dataframe of participants
colnames(participants) <- c("participant_id")
get_trial_count<-function(x){ #get number of trials completed (x = participant id)
trial_count<-sum(trialdata$participant == x)
return(trial_count)
}
participants$trial_count <-lapply(participants$participant_id, get_trial_count)
participants_incomplete <- subset(participants,trial_count < 324)
#dataframe of participants with complete data
participants_complete<- subset(participants,trial_count==324)
participants_ubercomplete<- subset(participants,trial_count>324)
trialdata <- subset(trialdata, !participant %in% participants_incomplete$participant_id) #subset trialdata for participants who completed all trials
#make column with trial number
#x=participant
for (x in 1:nrow(participants_complete)) {
trialdata$trialno <- c(1:324)
}
}
## RESCALE similarity to be 0-7 instead of -4/+4 - ONLY NECESSARY IF NOT ALREADY 0-7
{trialdata$similarity[trialdata$similarity == 4] <- 7
trialdata$similarity[trialdata$similarity == 3] <- 6
trialdata$similarity[trialdata$similarity == 2] <- 5
trialdata$similarity[trialdata$similarity == 1] <- 4
trialdata$similarity[trialdata$similarity == -1] <-3
trialdata$similarity[trialdata$similarity == -2] <-2
trialdata$similarity[trialdata$similarity == -3] <-1
trialdata$similarity[trialdata$similarity == -4] <-0
}
##CONVERT RGB TO HEX FOR GRAPHING (TRIALDATA)
{
#split rgb strings
#x=rgb string
splitrgb <-function(x){
variable<-str_replace_all(x, "\\[|\\]", "") #delete brackets
variable<-strsplit(variable, split = ",") #split string
variable<-lapply(variable, as.numeric)   #convert to numeric
variable<-lapply(variable, "+", 1)  #convert rgb scale
variable<-lapply(variable, "*", 127.5)
return (as.list(unlist(variable)))
}
trialdata$Circle1_colour <- lapply(trialdata[,"Circle1_colour"], splitrgb) #apply function
trialdata$Circle2_colour <- lapply(trialdata[,"Circle2_colour"], splitrgb)
#make dataframes with rows per r, g, and b
circle1_df <- as.data.frame(lapply(trialdata[,"Circle1_colour"], function(x) t(do.call(cbind, x))))
circle2_df <- as.data.frame(lapply(trialdata[,"Circle2_colour"], function(x) t(do.call(cbind, x))))
#swap rows and columns
circle1_df <- t(circle1_df)
circle2_df <- t(circle2_df)
#name columns
colnames(circle1_df) <- c("r1", "g1", "b1")
colnames(circle2_df) <- c("r2", "g2", "b2")
circle1_df<-as.data.frame(circle1_df)
circle2_df<-as.data.frame(circle2_df)
circle1_df$hex1 <- NA
circle2_df$hex2 <- NA
#rgb2hex function
rgb2hex <- function(r, g, b) {rgb(r, g, b, maxColorValue = 255)}
#Get hex in each circle dataframe
circle1_df$hex1 <- apply(circle1_df, 1, function(x) rgb2hex(x[1], x[2], x[3]))
circle2_df$hex2 <- apply(circle2_df, 1, function(x) rgb2hex(x[1], x[2], x[3]))
#bind circle colour dataframes to trialdata
trialdata <- cbind(trialdata, circle1_df, circle2_df)
}
#MAKE PASS COLUMNS IN TRIAL DATA
{
trialdata_passes<-trialdata
names(trialdata_passes)[names(trialdata_passes) == 'similarity'] <- 'firstpass_similarity'
trialdata_passes$secondpass_similarity <- NA
names(trialdata_passes)[names(trialdata_passes) == 'response_time'] <- 'firstpass_responsetime'
trialdata_passes$secondpass_responsetime<-NA
for (x in 0:(nrow(participants_complete)-1)) { #put 2nd pass data in that column (x = row number in participants_complete)
trialdata_passes$secondpass_similarity[((x*324)+1):((x*324)+162)] <- trialdata_passes$firstpass_similarity[((x*324)+163):((x*324)+324)]
trialdata_passes$secondpass_responsetime[((x*324)+1):((x*324)+162)] <- trialdata_passes$firstpass_responsetime[((x*324)+163):((x*324)+324)]
}
#delete extra rows
trialdata_passes <- na.omit(trialdata_passes)
#make a column with the mean similarity value from the two passes
means<-data.frame(similarity=rowMeans(trialdata_passes[,c("firstpass_similarity", "secondpass_similarity")]))
trialdata_passes<-cbind(trialdata_passes,means)
}
#CORRELATION DATAFRAME WITH ONE ROW PER PARTICIPANT
{
#make a dataframe to store correlation values
pass_correlation <- data.frame(participants_complete$participant_id)
names(pass_correlation)[names(pass_correlation) == 'participants_complete.participant_id'] <- 'participant'
pass_correlation$pearson<- NA
pass_correlation$spearman<- NA
#put correlation values into dataframe
#x <- participant id
getpearson<-function(z){
temp_df <- subset(trialdata_passes,participant==z)
pearson <- cor(x=temp_df$firstpass_similarity, y=temp_df$secondpass_similarity, method="pearson")
return(pearson)
}
getspearman<-function(z){
temp_df <- subset(trialdata_passes,participant==z)
spearman <- cor(x=temp_df$firstpass_similarity, y=temp_df$secondpass_similarity, method="spearman")
return(spearman)
}
pass_correlation$pearson<-lapply(participants_complete$participant, getpearson) #apply fn
pass_correlation$spearman<-lapply(participants_complete$participant, getspearman)
#make correlation numeric for graphing
pass_correlation$pearson<-as.numeric(pass_correlation$pearson)
pass_correlation$spearman<-as.numeric(pass_correlation$spearman)
#if error: check trialdata_passes that resulted in NA correlation
unique(unlist (lapply (pass_correlation, function (x) which (is.na (x)))))
#trialdata_passes[trialdata_passes$participant == '61652222bfd9351c91a6585a',]
#drop rows with NA correlation #
pass_correlation<- na.omit(pass_correlation)
#covert rho to fisher's z
#x=rho value
get_fisherz <-function(x){
variable<-(0.5*(log(1+x) - log(1-x)) )
return(variable)
}
pass_correlation$fisherz <- lapply(pass_correlation[,"pearson"], get_fisherz) #apply function
pass_correlation$fisherz<-as.numeric(pass_correlation$fisherz)
}
#save median
medianpass<- round(median(pass_correlation$pearson), 2)
#Same plot as above (hist of dp corr) with Lonni's viz
ggplot(pass_correlation, aes(pearson)) +
geom_histogram(fill= "#63B8FF") +
scale_x_continuous(breaks = as.numeric(round(quantile(pass_correlation$pearson),digits = 2))) +
theme_pubr() +
theme(axis.line = element_blank())+
geom_rangeframe()+
labs(x="doublepasscorrelation(rho)",
title= "Histogram of double pass correlations (rho)",
subtitle = paste("median=", medianpass))
ggplot(data)+
geom_bar(aes(OS))
low_FR <- data[data$frameRate<30,]
#READ FILES
{
## Pilot data with Ishihara
#make a list of data file names
pilot.files <- list.files(path="./data/Pilot data", pattern="*.csv", full.names=TRUE)
#make a dataframe binding all datafiles
pilot.data <- sapply(pilot.files, read.csv, simplify=FALSE) %>% bind_rows(.id = "fileId")
#adding Ishihara colomn missing to allow rbind
pilot.data$Ishi_textbox.text <- NA
##Data with Ishihara test
#make a list of data file names
files <- list.files(path="./data", pattern="*.csv", full.names=TRUE)
#make a dataframe binding all datafiles
data <- sapply(files, read.csv, simplify=FALSE) %>%
lapply(\(x) mutate(x, across(Ishi_textbox.text, as.character))) %>% bind_rows(.id = "fileId")
##Data with Ishihara test
#make a list of data file names
waveiv.files <- list.files(path="./data/wave IV", pattern="*.csv", full.names=TRUE)
#make a dataframe binding all datafiles
waveiv.data <- sapply(waveiv.files, read.csv, simplify=FALSE) %>%
lapply(\(x) mutate(x, across(Ishi_textbox.text, as.character))) %>% bind_rows(.id = "fileId")
##Data with Ishihara test
#make a list of data file names
pb.files <- list.files(path="./data/Problematic file", pattern="*.csv", full.names=TRUE)
#make a dataframe binding all datafiles
pb.data <- sapply(pb.files, read.csv, simplify=FALSE) %>%
lapply(\(x) mutate(x, across(Ishi_textbox.text, as.character))) %>% bind_rows(.id = "fileId")
pb.data$textbox.text <- as.character(pb.data$textbox.text)
data <- bind_rows(pb.data, data, pilot.data, waveiv.data)
}
low_FR <- data[data$frameRate<30,]
shitty_FR <- unique(low_FR$participant)
ggplot(low_FR)+
geom_bar(aes(frameRate))
ggplot(low_FR)+
geom_histogram(aes(frameRate))
low_FR <- data[data$frameRate<29,]
shitty_FR <- unique(low_FR$participant)
#remove empty cells
framedata <- framedata %>% drop_na()
framedata <- subset(framedata, framedata$frameRate>29)
mean(framedata$frameRate)
median(framedata$frameRate)
ggplot(framedata)+
geom_density(aes(frameRate))
ggplot(framedata)+
geom_density(aes(frameRate))+
theme_pubr
ggplot(framedata)+
geom_density(aes(frameRate))+
theme_pubr
ggplot(framedata)+
geom_density(aes(frameRate))+
theme_pubr()
summary(framedata$frameRate)
sd(framedata$frameRate)
library(munsell)
mnsl2hex("4R 7.5/6.5")
mnsl2hex("10R 8.0/6.5")
mnsl2hex("10R 8/6.5")
mnsl2hex("8YR 8.5/6.5")
mnsl2hex("5Y 9/6")
